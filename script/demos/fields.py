#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on 2024/07/24

@author: alain

-----------------------------------------------------
geonodes module
- Scripting Geometry Nodes
-----------------------------------------------------

module : demos/fields
---------------------
Builds Geometry Nodes to generate fields. Fields can be visualized with Arrows.

Two types of trees are built:
    - Field computation : groups which compute the field vectors at given locations
    - Field visualization : modifiers which visualizes the previus field

Electromagnetic fields
----------------------

The computing groups computes E and B fields from parameters.
The modifiers use the groups to visualize one of the two fields

- G X Moving Charge Field / X Moving Charge Field : a single charge moving along X axis
- G Moving Charge Field / Moving Charge Field : a single charge moving in an arbitraty direction
- G Charges on Curve Field / Charges on Curve Fielf : several charges moving along a curve
- G XY Loop Radial Field : the radial field generated by a single solenoid loop
- G XY Loop Field : the field generated by a single solenoid loop
- G Solenoid Field / Solenoid Field : the field generated by a solenoid
- G Electric Field / Electric Field : electric field generated by charges

Utilities
---------
- Compute Lines of Field : compute field lines from a field computation. The field group uses position as socket input.
  the output socket E or B is used as input of the group 'G Field Lines'

updates
-------
- creation : 2024/07/24
- update   : 2024/08/03
"""

import numpy as np

from .. import *

def demo():

    # =============================================================================================================================
    # Computing

    # -----------------------------------------------------------------------------------------------------------------------------
    # Frame change

    with GeoNodes("G Frame Change", is_group=True):

        position  = Vector(0, "Position")
        vector    = Vector(0, "Vector")

        center    = Vector(0, "Center")
        direction = Vector.Direction((1, 0, 0), "Direction")
        reverse   = Boolean(False, "Reverse")

        # ----- Rotation to have the direction along x axis

        with Layout("Rotation to have direction along x axis"):

            rotation = Rotation.AlignXToVector(vector=direction)
            inverse  = rotation.invert()

        # ----- Rotate vectors

        with Layout("Rotate vectors"):

            forward_vector  = inverse @ vector
            backward_vector = rotation @ vector

            transformed_vector = forward_vector.switch(reverse, backward_vector)

        # ----- Transformation locations

        with Layout("Transform locations"):

            forward_position  = inverse @ (position - center)
            backward_position = (rotation @ position) + center

            transformed_position = forward_position.switch(reverse, backward_position)

        transformed_position.to_output("Position")
        transformed_vector.to_output(  "Vector")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electric Field

    with GeoNodes("G Electric Field", is_group=True):

        position = Vector(0, "Position", tip="Position where to compute the field")

        charges  = Geometry(None, "Charges", tip="Charge locations with 'Charge' attribute")
        max_len  = Float(1000, "Max Length", 1, tip="Max field vector length")

        with Layout("Mesh or Points input"):
            cloud = charges.point_cloud + charges.mesh.points.to_points()
            count = cloud.points.count

        with Layout("Default charge to 1"):
            charge_val = Float.Named('Charge')
            charge_val = Float.Switch(charge_val.exists_, 1, charge_val)
            cloud.points.store('Charge', charge_val)

        with Repeat(field=Vector(), index=0, iterations=count) as rep:

            charge_loc = cloud.points.sample_index(nd.position, index=rep.index)
            charge_val = cloud.points.sample_index(Float.Named('Charge'), index=rep.index)

            v = position - charge_loc
            l = v.length
            l3 = gnmath.max(1/max_len, l**3)
            rep.field += charge_val*v/l3

            rep.index += 1

        rep.field.out("E")
        Vector().out("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a charge moving in an arbitray direction

    with GeoNodes("G Moving Charge Field", is_group=True) as tree:

        position   = Vector(0, "Position", tip="Position where to compute the fields")

        charge_loc = Vector(0, "Charge Location", tip="Location of the moving charge")
        charge     = Float(1,  "Charge", tip="Value of the charge")
        speed      = Vector((.8, 0, 0), "Speed", tip="Speed of the moving charge as a percentage of speed of light.")
        max_len    = Float(1000, "Max Length", 1, tip="Max field vector length")

        with Layout("Ensure beta is not greater than 1"):
            length = speed.length
            beta   = gnmath.min(length, .999)
            speed  = speed.scale(beta/length)

        with Layout("Gamma"):
            gamma = 1/gnmath.sqrt(1 - beta**2)

        with Layout("Align speed along X axis"):
            rotation = Rotation.AlignXToVector(speed)
            inv_rot  = rotation.invert()

            rotated_position = inv_rot @ (position - charge_loc)

        with Layout("Charge*gamma/rho**3"):
            rho = rotated_position.length
            gr3 = charge*gamma/rho**3

        with Layout("E and B in rotated frame"):
            E = gr3*rotated_position
            B = (gr3*beta)*Vector((0, -rotated_position.z, rotated_position.y))

        with Layout("Maximum length"):
            E = E.normalize().scale(gnmath.min(E.length, max_len))
            B = B.normalize().scale(gnmath.min(B.length, max_len))

        with Layout("Back to the initial frame"):
            E = rotation @ E
            B = rotation @ B

        E.out("E")
        B.out("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by charges along a curve

    with GeoNodes("G Curve Field", is_group=True):

        position    = Vector(0, "Position", tip="Position where to compute the field")

        source      = Curve(None, "Source Curve", tip="Curve on which charges are moving")
        count       = Integer(1, "Count", 1, 1000, tip="Number on charges on the curve")
        t           = Float(0, "t", tip="Time")
        charge      = Float(1, "Charge", tip="Charge value")
        beta        = Float(.8, "Beta", -.999, .999, tip="Charges speed in percentage of the speed of light")

        # ----------------------------------------------------------------------------------------------------
        # Main

        dt = 1/count
        spheres = Cloud.Points(count=count)

        with Repeat(spheres=spheres, field=Vector(), e=Vector(), b=Vector(), index=0, iterations=count) as rep:

            sample = source.sample(factor=abs(rep.index*dt + t) % 1)

            charge_loc   = sample.position_
            charge_speed = sample.tangent_.scale(beta)

            rep.spheres.points[rep.index].position = charge_loc

            field_node = Group("G Moving Charge Field", {
                'Position'       : position,
                'Charge'         : charge/count,
                'Charge Location': charge_loc,
                'Speed'          : speed,
                })

            rep.e += field_node.e
            rep.b += field_node.b

            rep.index += 1

        rep.e.out("E")
        rep.b.out("B")
        rep.spheres.out("Charge Locations")

    # =============================================================================================================================
    # Lorentz transformation for electromagnetic field

    with GeoNodes("EM Lorentz", is_group=True):

        speed = Vector((.8, 0, 0), "Speed")
        E     = Vector(0, "E")
        B     = Vector(0, "B")

        # ----- Make sure beta is ok

        with Layout("Ensure beta is not greater than 1"):
            length = speed.length
            beta   = gnmath.min(length, .999)
            speed  = speed.scale(beta/length)

        # ----- Rotate to have speed along x axis

        with Layout("Rotate fields to have speed long x axis"):

            rotation = Rotation.AlignXToVector(speed)
            inverse  = rotation.invert()

            E_rot = inverse @ E
            B_rot = inverse @ B

        # ----- Lorentz transformation

        with Layout("Lorentz transformation"):

            gamma = (1 - beta**2)**(-.5)

            Erx, Ery, Erz = E_rot.x, E_rot.y, E_rot.z
            Brx, Bry, Brz = B_rot.x, B_rot.y, B_rot.z

            E_rot_ = Vector((Erx, gamma*(Ery - beta*Brz), gamma*(Erz + beta*Bry)))
            B_rot_ = Vector((Brx, gamma*(Bry + beta*Erz), gamma*(Brz - beta*Ery)))

        # ----- Rotate back

        with Layout("Rotate back"):
            E_ = rotation @ E_rot_
            B_ = rotation @ B_rot_

        # ----- Done

        E_.out("E")
        B_.out("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a loop in the plane XY at distance r and altitude z

    with GeoNodes("G Loop Field", is_group=True):

        r      = Float(0, "r", tip="Distance to the center of the loop where to compute the field")
        z      = Float(0, "z", tip="z coordinate where to compute the field")
        charge = Float(1, "Charge", tip="Charge value")
        beta   = Float(.8, "Beta",  -.999, .999, tip="Charge speed in percentage of the speed of light")
        R      = Float(1, "Radius", .1, 10, tip="Radius of the loop")

        # -----------------------------------------------------------------------------------------------------------------------------
        # Main

        count = round(32*R)

        with Layout("Cosine and Sine"):
            circle = Mesh.Circle(vertices=count, radius=1)

        with Layout("-2*gamma*charge"):
            gam_charge = (-2*charge/count)*(1 - beta**2)**(-0.5)

        # Integration loop

        with Repeat(ex=0., ez=0., bx=0., bz=0., index=0, iterations=count) as rep:

            cos_sin = circle.points.sample_index(value=nd.position, index=rep.index)
            rep.index += 1

            cos_theta_, sin_theta_ = cos_sin.x, cos_sin.y

            rho_x = r - R*cos_theta_
            rho_y = R*sin_theta_
            gr3 = gam_charge*gnmath.max(.01, Vector((rho_x, rho_y, z)).length)**-3

            rep.ex += rho_x*gr3
            rep.ez += z*gr3

            rep.bx += z*cos_theta_*gr3
            rep.bz += (R - r*cos_theta_)*gr3

        with Layout("Fields"):
            Vector((rep.ex, 0, rep.ez)).out("E")
            Vector((rep.bx, 0, rep.bz)).out("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoid

    with GeoNodes("G Solenoid Field", is_group=True):

        position    = Vector(0,   "Position", tip="Position where to compute the fields")

        charge      = Float(1,    "Charge", tip="Total charge of the solenoid")
        beta        = Float(.8,   "Beta", -.999, .999, tip="Speed in percentage of the speed of light")
        R           = Float(1,    "Radius",  .1, 10, tip="Solenoid radius")
        loops       = Integer(10, "Loops", 10, tip="Number of loops")
        length      = Float(5,    "Length", .1, 10, tip="Solenoid length")

        with Layout("Position in cylindrical coordinates along x"):
            x = position.x
            r = Vector((0, position.y, position.z)).length
            lam = gnmath.atan2(position.z, position.y)

        with Layout("Integral along theta in [0, pi]"):
            theta0 = 0
            theta1 = pi
            theta_count = round(32*R)
            theta = nd.position.x

        with Layout("Sum on the loops in [-l/2, l/2]"):
            x_s0 = -length/2
            x_s1 = length/2
            x_s = nd.position.y

        with Layout("-2*gamma*charge"):
            gam_charge = (-2*charge/count)*(1 - beta**2)**(-0.5)

        with Layout("1/Rho**3"):
            rho3 = ((x - x_s)**2 + R**2*gnmath.sin(theta)**2 + (r - R*gnmath.cos(theta))**2)**(-1.5)

        with Layout("dEx"):
            dEx = (x - x_s)*rho3

        with Layout("dEy"):
            dEy = (r - R*gnmath.cos(theta))*rho3

        with Layout("dBx"):
            dBx = (R - r*gnmath.cos(theta))*rho3

        with Layout("dBy"):
            dBy = (x - x_s)*gnmath.cos(theta)*rho3

        integrals = macros.double_integrals(x0=theta0, x1=theta1, y0=x_s0, y1=x_s1, count_x=theta_count, count_y=loops, Ex=dEx, Ey=dEy, Bx=dBx, By=dBy)

        with Layout("Electric Field"):
            E = Vector((
                integrals["Ex"],
                integrals["Ey"]*(-gnmath.sin(lam)),
                integrals["Ey"]*gnmath.cos(lam)
            )).scale(gam_charge)

        with Layout("Magnetic Field"):
            B = Vector((
                integrals["Bx"],
                integrals["By"]*(-gnmath.sin(lam)),
                integrals["By"]*gnmath.cos(lam)
            )).scale(gam_charge*beta)

        E.out("E")
        B.out("B")


    return







# =============================================================================================================================
# Visualize a field computed by a group
#
# The group must take the following input nodes
#
# - Position     : locations where to compute the field
# - kwargs       : kwargs passed in the function

def gen_field_visualization(tree, field_node):

    # ----- Visualisation parameters

    elec_field  = tree.bool_input(  "Electric field",       True, description="Show electric field rather than magnetic field")
    color       = tree.color_input( "Color",                (0., 0., 1., 1.), description="'Color' named attribute to pass to the shader")
    transp      = tree.factor_input("Transparency",         0., min_value=0., max_value=1, description="'Transparency' named attribute to pass to the shader")

    # ----- Arrows

    scale       = tree.float_input( "Scale",                1., min_value=0., description="Vectors multiplicator")
    curl_vect   = tree.bool_input(  "Curl Vectors",         False, description="Use curl shape for arrows")

    # ----- Lines of field

    field_lines = tree.bool_input(  "Lines of field",       False, description="Lines of field (True) or field of vectors (False)")
    iterations  = tree.int_input(   "Iterations",           20, min_value=1, description="Number of iterations to compute the lines of field")
    delta       = tree.float_input( "Delta",                .1, min_value=.001, description="Distance to move at each iteration")
    int_fac     = tree.factor_input("Intensity",            .9, min_value=0., max_value=1., description="Use intensity named attribute for radius")
    rand_dir    = tree.bool_input(  "Random Direction",     False, description="Build lines in random directions rather than in both directions")

    # ----- Geometry parameters

    resol       = tree.int_input(     "Resolution",         12, min_value=3, max_value=64, description="Lines / arrows section resolution")
    section     = tree.float_input(   "Section",            .02, min_value=0., max_value=1., description="Lines / arrows section")
    material    = tree.material_input("Material",           "Arrow", description="Arrows / lines material")

    # ----- Show / Hide

    show        = tree.bool_input(    "Show",               True, description="Show / hide flag")

    # ====================================================================================================
    # Utilities

    def get_field():
        return field_node.b.switch(elec_field, field_node.e)

    def build_lines(points, direction):
        return tree.group("Compute Lines of Field",
            geometry    = points,
            field       = get_field(),
            iterations  = iterations,
            delta       = delta,
            direction   = direction,
            ).geometry

    # ====================================================================================================
    # Main

    with Layout("Starting points"):
        comps_node = tree.geometry.separate_components()
        points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
        points = points.points_to_vertices()

    # ----------------------------------------------------------------------------------------------------
    # Arrows

    with Layout("Arrows"):

        points.store_named_vector("Vectors", get_field())

        arrows = tree.group("Arrows", points,
            scale         = scale,
            resolution    = resol,
            section       = section,
            sphere        = curl_vect,
            color         = color,
            transparency  = transp,
            shaft         = material,
            head          = material,
            ).geometry

    # ----------------------------------------------------------------------------------------------------
    # Lines of field

    with Layout("Lines of field"):
        curves  = build_lines(points, 1)
        curves += build_lines(points, -1)

        curves = curves.switch(rand_dir, build_lines(points, tree.integer(1).switch(tree.random_boolean(.5), -1)))

        lines = tree.group("To Lines of Field",
                geometry         = curves,
                resolution       = resol,
                radius           = section,
                intensity_factor = int_fac,
                transparency     = transp,
                color            = color,
                material         = material,
                ).geometry

    mesh = arrows.switch(field_lines, lines)

    # ----- Done

    return mesh.switch(-show)

# =============================================================================================================================
# Build function

def build_fields(clear_sockets=False):

    arrows_module.build_arrows()
    print("\nCreate fields modifiers...")


    # =============================================================================================================================
    # Electromagnetic Field computations
    # The groups returns E and B sockets








    # -----------------------------------------------------------------------------------------------------------------------------
    # Field emitted by charges moving on a segment along X and centered on the origin

    with gn.GeoNodes("G Segment Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        length      = tree.float_input(  "Length",          1., min_value=0.01)

        # ----- Main

        x, y, z = position.x, position.y, position.z
        a2 = y**2 + z**2

        L = length/2

        with Layout("G(L) and F(L)"):

            lx1 = L - x
            GL1 = 1/tree.sqrt(a2 + lx1**2)
            FL1 = lx1/a2*GL1

        with Layout("G(-L) and F(-L)"):

            lx0 = -L - x
            GL0 = 1/tree.sqrt(a2 + lx0**2)
            FL0 = lx0/a2*GL0

        with Layout("Integrals"):
            FL = FL1 - FL0
            GL = GL1 - GL0

        with Layout("Gamma"):
            gamma = charge*(1 - beta**2)**1.5

        E = gamma*tree.vector((GL, y*FL, z*FL))
        B = gamma*beta*tree.vector((0, -z*FL, y*FL))

        E.to_output("E")
        B.to_output("B")

        tree.CurveLine(start=(-L, 0, 0), end=(L, 0, 0)).curve.to_output("Segment")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Field emitted by charges moving on a rectangular shape in the plane XY

    with gn.GeoNodes("G Rectangle Loop Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        size_y      = tree.float_input(  "Size Y",          1., min_value=0.01)
        size_z      = tree.float_input(  "Size Z",          1., min_value=0.01)

        with Layout("Share the charge on the sides"):
            total_size = (size_y + size_z)*2
            charge_y = charge*size_y/total_size
            charge_z = charge*size_z/total_size

        with Layout("Computation are made in plane XY"):
            position = position.rotate_vector(rotation=(0, np.pi/2, 0))

        node = tree.group("G Segment Field",
                    position = position - tree.vector((0, size_z*(-.5), 0)),
                    charge   = charge_y,
                    beta     = beta,
                    length   = size_y,
                    )

        E = node.e
        B = node.b

        node = tree.group("G Segment Field",
                    position = position - tree.vector((0, size_z/2, 0)),
                    charge   = -charge_y,
                    beta     = beta,
                    length   = size_y,
                    )

        E += node.e
        B += node.b

        rot_pos = position.rotate_vector(rotation=(0, 0, np.pi/2))
        rotation = tree.vector((0, 0, -np.pi/2))

        node = tree.group("G Segment Field",
                    position = rot_pos - tree.vector((0, size_y*(-.5), 0)),
                    charge   = charge_z,
                    beta     = beta,
                    length   = size_z,
                    )

        E += node.e.rotate_vector(rotation)
        B += node.b.rotate_vector(rotation)

        node = tree.group("G Segment Field",
                    position = rot_pos - tree.vector((0, size_y/2, 0)),
                    charge   = -charge_z,
                    beta     = beta,
                    length   = size_z,
                    )

        E += node.e.rotate_vector(rotation)
        B += node.b.rotate_vector(rotation)

        with Layout("Rotate the loop in the plane YZ"):

            E = E.rotate_vector(rotation=(0, -np.pi/2, 0))
            B = B.rotate_vector(rotation=(0, -np.pi/2, 0))

            curve = tree.Grid(size_x=size_y, size_y=size_z, vertices_x=2, vertices_y=2).mesh.mesh_to_curve()
            curve.transform_geometry(rotation=(0, -np.pi/2, 0))


        E.to_output("E")
        B.to_output("B")

        curve.to_output("Rectangle")

    # =============================================================================================================================
    # Compute Curl

    with gn.GeoNodes("Compute Curl", clear_sockets=clear_sockets) as tree:

        # ----- Parameters

        field       = tree.vector_input(  "Field", description="Field computation from 'position' Node")
        ds          = tree.float_input(   "ds", .1, min_value=0.001, description="Precision")
        normalize   = tree.bool_input(    "Normalize", True, description="Return the raw (False) or normalized (True)")
        scale       = tree.float_input(   "Scale", 1., description="Scale")

        # ---- Main

        with Layout("Computation points"):
            comps_node = tree.geometry.separate_components()
            points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
            points = points.points_to_vertices()

        ds2_ = -.5*ds

        with Layout("Along X"):
            points.transform_geometry(translation=(ds2_, 0, 0))
            points.POINT.store_named_vector("Before", field)
            points.transform_geometry(translation=(ds, 0, 0))
            points.POINT.store_named_vector("After", field)
            points.transform_geometry(translation=(ds2_, 0, 0))

            points.POINT.store_named_vector("dvx", points.POINT.named_vector("After") - points.POINT.named_vector("Before"))

        with Layout("Along Y"):
            points.transform_geometry(translation=(0, ds2_, 0))
            points.POINT.store_named_vector("Before", field)
            points.transform_geometry(translation=(0, ds, 0))
            points.POINT.store_named_vector("After", field)
            points.transform_geometry(translation=(0, ds2_, 0))

            points.POINT.store_named_vector("dvy", points.POINT.named_vector("After") - points.POINT.named_vector("Before"))

        with Layout("Along Z"):
            points.transform_geometry(translation=(0, 0, ds2_))
            points.POINT.store_named_vector("Before", field)
            points.transform_geometry(translation=(0, 0, ds))
            points.POINT.store_named_vector("After", field)
            points.transform_geometry(translation=(0, 0, ds2_))

            points.POINT.store_named_vector("dvz", points.POINT.named_vector("After") - points.POINT.named_vector("Before"))

        with Layout("Curl"):
            dvx, dvy, dvz = points.POINT.named_vector("dvx"), points.POINT.named_vector("dvy"), points.POINT.named_vector("dvz")
            curl = tree.vector((
                dvy.z - dvz.y,
                dvx.z - dvz.x,
                dvx.y - dvy.x,
            ))
            curl = curl.scale(scale)
            points.POINT.store_named_vector("Vectors", curl.switch(normalize, curl.scale(1/ds)))

        points.remove_named_attribute("Before")
        points.remove_named_attribute("After")
        points.remove_named_attribute("dvx")
        points.remove_named_attribute("dvy")
        points.remove_named_attribute("dvz")

        tree.geometry = points



    # =============================================================================================================================
    # Compute the lines of field

    with gn.GeoNodes("Compute Lines of Field", clear_sockets=clear_sockets) as tree:

        # ----- Field

        field       = tree.vector_input(  "Field", description="Field computation from 'position' Node")

        # ----- Algorithm parameter

        iterations  = tree.int_input(     "Iterations", 20,    min_value=1, description="Number of iterations per line")
        delta       = tree.float_input(   "Delta",      .1,    min_value=.001, description="Distance to move at each iteration")
        direction   = tree.float_input(   "Direction",  1., description="Move forwards (+1) or backwards (-1)")
        origin      = tree.vector_input(  "Origin", description="Origin to compute the distance from")
        max_dist    = tree.float_input(   "Max Distance",  100., description="Ignore points beyond the max distance")

        # ----------------------------------------------------------------------------------------------------
        # Main

        with Layout("Starting points"):
            comps_node = tree.geometry.separate_components()
            points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
            points = points.points_to_vertices()

            points.store_named_float("DELTA", delta*direction)
            points.POINT.delete_geometry(origin.distance(tree.position).greater_than(max_dist))

        with tree.repeat(points=points, top=True, iterations=iterations) as rep:

            with Layout("Vector computation"):

                with Layout("Displacement from current points"):
                    v0 = field
                    l0 = v0.length()

                    rep.points.POINT[rep.top].store_named_float("Intensity", l0)

                    #rep.top &= l0 < 10
                    rep.top &= l0 > 0.001

                    v0 = v0.normalize().scale(rep.points.named_float("DELTA"))

                with Layout("Extrude from this first displacement"):

                    mesh = rep.points.POINT[rep.top].extrude_mesh(offset=v0)
                    top  = mesh.node.top

                with Layout("Displacement from extruded point"):

                    v1 = field
                    v1 = v1.normalize().scale(rep.points.named_float("DELTA"))
                    #v1 = tree.vector((0, 0, 0)).switch(average, (v1 - v0).scale(.5))
                    v1 = (v1 - v0).scale(.5)

                    rep.points.POINT[top].offset = v1

            rep.top    = top
            rep.points = mesh

        mesh = rep.points
        mesh.remove_named_attribute("DELTA")

        tree.geometry = mesh.mesh_to_curve()

    # =============================================================================================================================
    # Visualize spheres on points

    def gen_spheres_on_charges(tree, charges_loc):

        sph_radius   = tree.float_input(   "Spheres Radius",   .1, min_value=0., description="Spheres radius (0 if charges must not be visualized)")
        sph_color    = tree.color_input(   "Spheres Color", description="Spheres 'Color' named attribute to pass to the Shader")
        sph_mat      = tree.material_input("Spheres Material", description="Spheres material")

        with Layout("Spheres on charges"):
            charges_loc.store_named_vector("Color", sph_color)
            spheres = charges_loc.instance_on_points(instance=tree.UVSphere(radius=sph_radius).mesh)
            spheres = spheres.realize_instances()
            spheres.FACE.shade_smooth = True
            spheres.FACE.material = sph_mat

        return spheres.switch(sph_radius.equal(0))

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("Electric Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charges_obj = tree.object_input("Charges location", 1., description="Geometry proving the locations of the charges")
        charge_min  = tree.float_input( "Min Charge", -1., description="Minimum value for electric charge")
        charge_max  = tree.float_input( "Max Charge",  1., description="Maximum value for electric charge")
        seed = tree.int_input(          "Seed",        0,  description="Random seed")

        # ----- Main

        charges = charges_obj.object_info().geometry
        charges.POINT.store_named_float("Charge", tree.random_float(min=charge_min, max=charge_max, seed=seed))

        field_node = tree.group("G Electric Field",
            position = tree.position,
            charges  = charges,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, charges)

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("X Moving Charge Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charge      = tree.float_input(  "Charge", 1., description="Value of the charge")
        beta        = tree.float_input(  "Beta",   0, min_value=-.999, max_value=.999, description="Beta relativist speed")
        t           = tree.float_input(  "t", description="Time")
        max_len     = tree.float_input(  "Max Lengh", 1., description="Max Vectors Length")

        # ----- Main

        field_node = tree.group("G X Moving Charge Field",
            position   = tree.position,
            charge     = charge,
            beta       = beta,
            t          = t,
            max_length = max_len,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, tree.Points(count=1, position=(beta*t, 0, 0)).points)
        field_node.charge_location.to_output("Charge location")

    # ----------------------------------------------------------------------------------------------------
    # A charge moving in an arbitrary direction

    with gn.GeoNodes("Moving Charge Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charge_loc  = tree.vector_input( "Charge location", description="Charge location")
        charge      = tree.float_input(  "Charge",  1., description="Value of the charge")
        speed       = tree.vector_input( "Speed", (.8, 0, 0), description="Charge speed (length must be less than 1)")

        # ----- Main

        field_node = tree.group("G Moving Charge Field",
            position        = tree.position,
            charge_location = charge_loc,
            speed           = speed,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, tree.Points(count=1, position=charge_loc).points)

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by several charges

    with gn.GeoNodes("Charges on Curve Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters0

        source_curve = tree.object_input(  "Source Curve", description="Curve on which charges are moving")
        count        = tree.int_input(     "Charges count",    10, min_value=1, max_value=1000, description="Number of charges")
        t            = tree.float_input(   "t",                0., description="Time for charges animation")
        charge       = tree.float_input(   "Charge",           1., description="Total charge")
        beta         = tree.float_input(   "Beta",             .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        sph_radius   = tree.float_input(   "Spheres Radius",   .1, min_value=0., description="Charges sphere radius (0 if charges must not be visualized)")
        sph_mat      = tree.material_input("Spheres Material", description="Charges material")

        # ----- Main

        curve = source_curve.object_info().geometry

        field_node = tree.group("G Charges on Curve Field",
            position        = tree.position,
            source_curve    = curve,
            count           = count,
            t               = t,
            charge          = charge,
            beta            = beta,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with Layout("Spheres"):

            sph_locs = field_node.charge_locations
            spheres = sph_locs.instance_on_points(instance=tree.UVSphere(radius=sph_radius).mesh)
            spheres.FACE.shade_smooth = True
            spheres.FACE.material = sph_mat

        tree.geometry = field_visu + spheres.switch(sph_radius.equal(0))

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoide

    with gn.GeoNodes("Solenoid Field", clear_sockets=clear_sockets) as tree:

        charge      = tree.float_input(  "Charge",      1., description="Total charge")
        beta        = tree.float_input(  "Beta",        .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        radius      = tree.float_input(  "Radius",      1., min_value=.1, max_value=10, description="Solenoid radius")
        length      = tree.float_input(  "Length",      5., min_value=.1, max_value=10, description="Solenoid length")

        # ---- Solenoid

        wire_radius  = tree.float_input(   "Wire radius", .1, min_value=.001, description="Radius of the wire (0 for no visualization)")
        wire_mat     = tree.material_input("Wire Material", description="Wire material")

        # ----- Main

        field_node = tree.group("G Solenoid Field",
            position        = tree.position,
            charge          = charge,
            beta            = beta,
            radius          = radius,
            length          = length,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with Layout("Solenoid"):

            loops = tree.min(30, tree.max(1, length/2/wire_radius))

            wire_curve = tree.Spiral(
                #resolution      = 32,
                rotations       = loops,
                start_radius    = radius,
                end_radius      = radius,
                height          = length,
                ).curve

            wire_curve.transform_geometry(translation=(-length/2, 0, 0), rotation=(0, np.pi/2, 0))

            wire = wire_curve.curve_to_mesh(profile_curve=tree.CurveCircle(radius=wire_radius, resolution=12).curve)

            wire.FACE.shade_smooth = True
            wire.FACE.material     = wire_mat

        tree.geometry = field_visu + wire.switch(wire_radius.equal(0))

    # =============================================================================================================================
    # Magnet

    # -----------------------------------------------------------------------------------------------------------------------------
    # A single magnetic loop from a magnet
    #
    # Loop is an ellipsis tangent to x axis defined by its length (along x)
    # and width scale (along y)

    with gn.GeoNodes("Magnet Single Loop", clear_sockets=clear_sockets) as tree:

        length      = tree.float_input("Length", 1., min_value=0.)
        width_scale = tree.float_input("Width Scale",  1., min_value=0.01)
        angle       = tree.angle_input("Angle",  0.)
        count       = tree.int_input(  "Resolution", 32, min_value=3)

        # ----- Main

        width = length * width_scale

        circle = tree.MeshCircle(vertices=count, radius=1).mesh
        x, y = tree.position.x, tree.position.y
        circle.POINT.store_named_float("Intensity", (1.01 - y)*length)

        x = tree.position.x * length
        y = tree.position.y * width + width
        z = tree.position.z

        circle.POINT.position = tree.vector((x, y, z))
        circle.transform_geometry(rotation=(angle, 0, 0))

        tree.geometry = circle.mesh_to_curve()

    # -----------------------------------------------------------------------------------------------------------------------------
    # Magnet loops
    #
    # Compute the magnetic field loops from the points in the input geometry
    #
    # Given x, y, what is r such as:
    # x^ + (y - r)^2 = r^2
    # r = (x^2 + y^2)/2y

    with gn.GeoNodes("Magnet Loops", clear_sockets=clear_sockets) as tree:

        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01)
        location     = tree.vector_input(  "Location")
        rotation     = tree.rotation_input("Rotation")

        # ----- Input points

        with Layout("Input points"):
            comps = tree.geometry.separate_components()
            points = comps.point_cloud + comps.mesh.mesh_to_points()
            n = points.CLOUD.domain_size().point_count

        # ----- Computation is made for a magnet centered along the x axis

        with Layout("Center Magnet and align along x"):
            points.POINT.position = (tree.position - location).rotate_vector(rotation.clone.invert_rotation())

        # ----- Loop on the input points

        with tree.repeat(geometry=None, index=0, iterations=n) as rep:

            p = points.sample_index_vector(index=rep.index, value=tree.position)
            rep.index += 1

            x, y, z = p.x, p.y, p.z

            # ----- Plane passing through x axis

            angle = tree.arctan2(z, y)
            rot_y = tree.sqrt(y**2 + z**2)

            # ----- Width scale

            y_ = rot_y/width_scale

            r = (x**2 + y_**2)/2/y_

            # ----- Add a loop

            rep.geometry += tree.group("Magnet Single Loop",
                length      = r,
                width_scale = width_scale,
                angle       = angle,
                resolution  = 20 + r*20,
                ).geometry

        with Layout("Back to initial frame"):
            curves = rep.geometry
            curves.POINT.position = location + tree.position.rotate_vector(rotation)

        # ----- Done

        tree.geometry = curves

    # ----------------------------------------------------------------------------------------------------
    # Magnet field

    with gn.GeoNodes("G Magnet Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position     = tree.vector_input(  "Position")
        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01)
        location     = tree.vector_input(  "Location")
        rotation     = tree.rotation_input("Rotation")
        speed        = tree.vector_input(  "Speed")

        # ----- Computation is made for a magnet centered along the x axis

        with Layout("Center Magnet and align along x"):
            position = (position - location).rotate_vector(rotation.clone.invert_rotation())

            x, y, z = position.x, position.y, position.z

        # ----- Plane passing through x axis

        with Layout("Plane containing point and x axis"):
            angle = tree.arctan2(z, y)
            rot_y = tree.sqrt(y**2 + z**2)

        # ----- Width scale

        y_ = rot_y/width_scale

        # ----- Normalized radius

        r = (x**2 + y_**2)/2/y_

        # ----- Normalized B

        B = tree.vector(((r - y_)/width_scale, x, 0)).normalize()

        # ----- Rotation

        B = B.rotate_vector(rotation=(angle, 0, 0))

        # ----- Back to the initial frame

        B = B.rotate_vector(rotation)

        with Layout("Take speed into account"):

            transf_node = tree.group("EM Lorentz", speed=speed, b=B)
            E = transf_node.e
            B = transf_node.b

        # ----- Done

        E.to_output("E")
        B.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Magnet Shape

    with gn.GeoNodes("Magnet Shape", clear_sockets=clear_sockets) as tree:

        location     = tree.vector_input(   "Location")
        rotation     = tree.rotation_input( "Rotation")

        # ----- Magnet shape

        round_profile = tree.bool_input(    "Round Profile", False)
        magnet_length = tree.float_input(   "Length", 1.)
        profile_size  = tree.float_input(   "Profile Size",  .3)
        profile_scale = tree.float_input(   "Profile Scale", .8)
        material      = tree.material_input("Material")
        show          = tree.bool_input(    "Show",           True)

        # ----- Magnet shape

        rect = tree.Grid(size_x=profile_size, size_y=profile_size*profile_scale, vertices_x=2, vertices_y=2).mesh.mesh_to_curve()
        ell  = tree.CurveCircle(radius=profile_size/2).curve.transform_geometry(scale=(1, profile_scale, 1))

        prof = rect.switch(round_profile, ell)
        prof.POINT.store_named_float("uvy", tree.spline_parameter.factor)

        base = tree.CurveLine(start=(magnet_length*(-.5), 0, 0), end=(magnet_length*.5, 0, 0)).curve
        base.POINT.store_named_float("uvx", tree.spline_parameter.factor)

        shape = base.curve_to_mesh(profile_curve=prof, fill_caps=True)
        shape.CORNER.store_named_vector("UVMap", tree.vector((shape.named_float("uvx"), shape.named_float("uvy"), 0)))
        shape.FACE.shade_smooth = False
        shape.FACE.material     = material

        shape = shape.transform_geometry(translation=location, rotation=rotation)

        tree.geometry = shape.switch(-show)

    # =============================================================================================================================
    # A full Magnet

    with gn.GeoNodes("Magnet", clear_sockets=clear_sockets) as tree:

        #raise tree.Break()

        # ----- Magnet specs

        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01, description="Magnet field scale")
        location     = tree.vector_input(  "Location", description="Magnet location")
        rotation     = tree.rotation_input("Rotation", description="Magnet rotation")
        speed        = tree.vector_input(  "Speed",    description="Magnet speed")

        # ----- Magnet shape

        show_magnet   = tree.bool_input(    "Show Magnet")
        round_profile = tree.bool_input(    "Round Profile", False)
        magnet_length = tree.float_input(   "Length", 1.)
        profile_size  = tree.float_input(   "Profile Size",  .3)
        profile_scale = tree.float_input(   "Profile Scale", .8)
        magnet_mat    = tree.material_input("Magnet Material")

        # ----- Magnetic loops

        show_loops   = tree.bool_input(     "Show Magnetic Loops", True)
        loop_int_fac = tree.factor_input(   "Mag Lines Intensity", 1., min_value=0., max_value=1.)
        loop_section = tree.float_input(    "Mag Lines Section", .02, min_value=0., max_value=1.)
        min_loop_sec = tree.float_input(    "Min Mag Lines Section", 0, min_value=0., max_value=1.)
        loop_color   = tree.color_input(    "Mag Lines Color", (0, 1, 0, 1))
        loop_transp  = tree.factor_input(   "Mag Lines Transparency", 0., min_value=0., max_value=1.)
        loop_mat     = tree.material_input( "Mag Lines Material", "Arrow")

        loop_arrows  = tree.bool_input(     "Show Loops Arrows",    True)
        ar_scale     = tree.float_input(    "Scale",                1., min_value=0.)
        ar_dist      = tree.float_input(    "Distance",             .5, min_value=.1, )
        ar_section   = tree.float_input(    "Section",              .02, min_value=0., max_value=1.)
        ar_color     = tree.color_input(    "Color",                (0, 1, 0, 1))
        ar_transp    = tree.factor_input(   "Transparency",         0., min_value=0., max_value=1.)
        ar_mat       = tree.material_input( "Material",             "Arrow")

        # ----- Magnetic Arrows

        show_arrows  = tree.bool_input(     "Show Arrows",    True)

        # ----- Electric Field

        eshow_field   = tree.bool_input(     "Show Electric Field", False)
        e_max_dist    = tree.float_input(    "Max Distance to Magnet")
        eloop_int_fac = tree.factor_input(   "Elec Lines Intensity", 1., min_value=0., max_value=1.)
        eloop_section = tree.float_input(    "Elec Lines Section", .02, min_value=0., max_value=1.)
        min_eloop_sec = tree.float_input(    "Min Elec Lines Section", 0, min_value=0., max_value=1.)
        eloop_color   = tree.color_input(    "Elec Lines Color", (1, 0, 1, 1))
        eloop_transp  = tree.factor_input(   "ELec Lines Transparency", 0., min_value=0., max_value=1.)
        eloop_mat     = tree.material_input( "Elec Lines Material", "Arrow")

        eloop_arrows  = tree.bool_input(     "Show Elec Line Arrows",    False)

        ef_iterations = tree.int_input(      "Iterations", 20, min_value=2)
        ef_delta      = tree.float_input(    "Delta",      .1, min_value=0.001)

        ear_scale     = tree.float_input(    "Elec Scale",                1., min_value=0.)
        ear_dist      = tree.float_input(    "Elec Distance",             .5, min_value=.1, )
        ear_section   = tree.float_input(    "Elec Section",              .02, min_value=0., max_value=1.)
        ear_color     = tree.color_input(    "Elec Color",                (1, 0, 1, 1))
        ear_transp    = tree.factor_input(   "Elec Transparency",         0., min_value=0., max_value=1.)
        ear_mat       = tree.material_input( "Elec Material",             "Arrow")

        eshow_arrows  = tree.bool_input(     "Show Elec Arrows",    False)

        # ----- Main

        field_node = tree.group("G Magnet Field",
            position     = tree.position,
            width_scale  = width_scale,
            location     = location,
            rotation     = rotation,
            speed        = speed,
            )

        # ----- Magnet shape

        geo = tree.group("Magnet Shape",
                    location      = location,
                    rotation      = rotation,
                    round_profile = round_profile,
                    length        = magnet_length,
                    profile_size  = profile_size,
                    profile_scale = profile_scale,
                    material      = magnet_mat,
                    show          = show_magnet,
                    )

        # ----- Magnetic Field loops

        with Layout("Magnet loops"):

            loops_node = tree.group("Magnet Loops",
                geometry     = tree.geometry,
                width_scale  = width_scale,
                location     = location,
                rotation     = rotation,
            )

            lines_mesh = tree.group("Field Curve to Mesh",
                geometry           = loops_node.geometry,
                show_lines         = show_loops,
                intensity          = loop_int_fac,
                lines_section      = loop_section,
                min_lines_section  = min_loop_sec,
                lines_color        = loop_color,
                lines_transparency = loop_transp,
                lines_material     = loop_mat,

                show_arrows        = loop_arrows,
                scale              = ar_scale,
                distance           = ar_dist,
                section            = ar_section,
                color              = ar_color,
                transparency       = ar_transp,
                material           = ar_mat,
            ).geometry

            geo += lines_mesh

        # ----- Arrows

        with Layout("Arrows"):

            points = tree.geometry
            points.POINT.store_named_vector("Vectors", field_node.b)

            arrows = tree.group("Arrows",
                geometry     = points,
                scale        = ar_scale,
                section      = ar_section,
                color        = ar_color,
                transparency = ar_transp,
                shaft        = ar_mat,
                head         = ar_mat,
                show         = show_arrows,
                ).geometry

            geo += arrows

        # ----- Electric field

        with Layout("Electric Field"):

            elec_field_node = tree.group("Compute Lines of Field",
                geometry     = tree.geometry,
                field        = field_node.e,
                iterations   = ef_iterations.switch(tree.is_viewport, ef_iterations/10),
                delta        = ef_delta.switch(tree.is_viewport, ef_delta*10),
                direction    = tree.float(-1).switch(tree.random_boolean(probability=.5), 1),
                origin       = location,
                max_distance = e_max_dist,
            )

            lines_mesh = tree.group("Field Curve to Mesh",
                geometry           = elec_field_node.geometry,
                show_lines         = eshow_field,
                intensity          = eloop_int_fac,
                lines_section      = eloop_section,
                min_lines_section  = min_eloop_sec,
                lines_color        = eloop_color,
                lines_transparency = eloop_transp,
                lines_material     = eloop_mat,

                show_arrows        = eloop_arrows,
                scale              = ear_scale,
                distance           = ear_dist,
                section            = ear_section,
                color              = ear_color,
                transparency       = ear_transp,
                material           = ear_mat,
            ).geometry

            geo += lines_mesh

        # ----- Arrows

        with Layout("Electric Arrows"):

            points = tree.geometry
            points.POINT.store_named_vector("Vectors", field_node.e)

            arrows = tree.group("Arrows",
                geometry     = points,
                scale        = ear_scale,
                section      = ear_section,
                color        = ear_color,
                transparency = ear_transp,
                shaft        = ear_mat,
                head         = ear_mat,
                show         = eshow_arrows,
                ).geometry

            geo += arrows

        # ----- Done

        tree.geometry = geo

    # =============================================================================================================================
    # Quick Solenoid

    # -----------------------------------------------------------------------------------------------------------------------------
    # A single loop

    with gn.GeoNodes("Solenoid Single Magnetic Loop") as tree:

        position = tree.vector_input("Position")

        radius = tree.float_input("Radius", 1., min_value=.1)
        length = tree.float_input("Length", 5., min_value=.1)

        length_factor = tree.float_input("Length factor", 1.2, min_value=0)
        radial_factor = tree.float_input("Radial factor", 1.2, min_value=0)

        with Layout("Cylindrical coordinates"):
            x, y, z = position.x, position.y, position.z
            rho   = tree.vector((0, y, z)).length()
            theta = tree.arctan2(z, y)

        with Layout("Circle Radius to match length along X"):
            radius_x = rho.map_range(from_min=0, from_max=radius, to_min=(radius + length)*length_factor, to_max=0)

        with Layout("Base Circle"):
            circle=tree.curve_circle(radius=1, resolution=12 + radius_x*20)

        with Layout("Intensity"):
            cy = tree.position.y
            circle.POINT.store_named_float("Intensity", 1.01 - cy)


        with Layout("Deform along Y"):
            scale_y = rho.map_range(from_min=0, from_max=radius, to_min=radial_factor, to_max=0)
            radius_y = radius_x*scale_y
            circle = circle.transform_geometry(translation=(0, rho + radius_y, 0), scale=(radius_x, radius_x*scale_y, 1))

        circle = circle.transform_geometry(rotation=(theta, 0, 0))

        tree.geometry = circle

    # -----------------------------------------------------------------------------------------------------------------------------
    # A full magnetic field from a Solenoid

    with gn.GeoNodes("Solenoid Magnetic Field") as tree:

        density = tree.float_input(   "Density", 10, min_value= 0.)
        seed    = tree.integer_input( "Seed",    0)
        radius  = tree.float_input(   "Radius",  1., min_value=.1)
        length  = tree.float_input(   "Length",  5., min_value=.1)

        length_factor = tree.float_input("Length factor", 1.2, min_value=0)
        radial_factor = tree.float_input("Radial factor", 1.2, min_value=0)


        with Layout("Random source point"):
            disk = tree.MeshCircle(radius=radius, fill_type='NGON').mesh
            disk.transform_geometry(rotation=(0, gn.half_pi, 0))

            points = disk.distribute_points_on_faces(density_max=density*10, density_factor=density, seed=seed, distribute_method='POISSON', distance_min=radius/10).points
            count = points.CLOUD.domain_size().point_count


        with tree.repeat(geometry=None, index = 0, iterations=count) as rep:

            with Layout("Current point"):
                position = points.sample_index_vector(value=tree.position, index=rep.index)

            circle = tree.group("Solenoid Single Magnetic Loop",
                position = position,
                radius = radius,
                length = length,
                length_factor = length_factor,
                radial_factor = radial_factor,
                ).geometry

            rep.geometry += circle
            rep.index += 1

        circles = rep.geometry

        mesh = tree.group("Field Curve to Mesh",
            geometry            = circles,
            show_lines          = tree.bool_input("Show circles"),
            lines_section       = 0.02,
            lines_color         = tree.color_input("Circle Color"),
            lines_transparency  = tree.factor_input("Circles_transparency", min_value=0, max_value=1),
            show_arrows         = tree.bool_input("Show Arrows"),
            distance            = tree.float_input("Distance", .1, min_value=0.0001),
            scale               = tree.float_input("Scale", 1.),
            color               = tree.color_input("Color"),
            transparency        = tree.factor_input("Transparency", min_value=0, max_value=1),
            ).geometry

        tree.geometry = circles.switch(-tree.bool_input("Show Curves")) + mesh
