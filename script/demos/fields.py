#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on 2024/07/24

@author: alain

-----------------------------------------------------
geonodes module
- Scripting Geometry Nodes
-----------------------------------------------------

module : demos/fields
---------------------
Builds Geometry Nodes to generate fields. Fields can be visualized with Arrows.

Two types of trees are built:
    - Field computation : groups which compute the field vectors at given locations
    - Field visualization : modifiers which visualizes the previus field

Electromagnetic fields
----------------------

The computing groups computes E and B fields from parameters.
The modifiers use the groups to visualize one of the two fields

- G X Moving Charge Field / X Moving Charge Field : a single charge moving along X axis
- G Moving Charge Field / Moving Charge Field : a single charge moving in an arbitraty direction
- G Charges on Curve Field / Charges on Curve Fielf : several charges moving along a curve
- G XY Loop Radial Field : the radial field generated by a single solenoid loop
- G XY Loop Field : the field generated by a single solenoid loop
- G Solenoid Field / Solenoid Field : the field generated by a solenoid
- G Electric Field / Electric Field : electric field generated by charges

Utilities
---------
- Compute Lines of Field : compute field lines from a field computation. The field group uses position as socket input.
  the output socket E or B is used as input of the group 'G Field Lines'

updates
-------
- creation : 2024/07/24
- update   : 2024/08/03
"""

import numpy as np

from .. import *
from . import arrows as arrows_module

def demo():

    print("\nCreate fields Geometry Nodes...")

    arrows_module.demo()

    field_prefix = "Field"
    util_prefix  = "Util"
    show_prefix  = "Show"

    # =============================================================================================================================
    # Computing

    # -----------------------------------------------------------------------------------------------------------------------------
    # Frame change

    with GeoNodes("Frame Change", is_group=True, prefix=util_prefix):

        position  = Vector(0, "Position")
        vector    = Vector(0, "Vector")

        center    = Vector(0, "Center")
        direction = Vector.Direction((1, 0, 0), "Direction")
        reverse   = Boolean(False, "Reverse")

        # ----- Rotation to have the direction along x axis

        with Layout("Rotation to have direction along x axis"):

            rotation = Rotation.AlignXToVector(vector=direction)
            inverse  = rotation.invert()

        # ----- Rotate vectors

        with Layout("Rotate vectors"):

            forward_vector  = inverse @ vector
            backward_vector = rotation @ vector

            transformed_vector = forward_vector.switch(reverse, backward_vector)

        # ----- Transformation locations

        with Layout("Transform locations"):

            forward_position  = inverse @ (position - center)
            backward_position = (rotation @ position) + center

            transformed_position = forward_position.switch(reverse, backward_position)

        transformed_position.to_output("Position")
        transformed_vector.to_output(  "Vector")

    # =============================================================================================================================
    # Compute Curl

    with GeoNodes("Compute Curl", is_group=True, prefix=util_prefix) as tree:

        # ----- Parameters

        field       = Vector(0, "Field", tip="Field vector at the input geometry points")
        ds          = Float(.1,  "ds", 0.001, tip="Precision")
        normalize   = Boolean(True, "Normalize", tip="Return the raw (False) or normalized (True) field")
        scale       = Float(1, "Scale", tip="Scale")

        # ---- Main

        with Layout("Computation points"):
            geo = Geometry()
            cloud = geo.point_cloud + geo.mesh.points.to_points()

        ds2_ = (-.5*ds)._lc("ds/2")

        with Layout("TEMP Along X"):
            cloud.points.offset = (ds2_, 0, 0)
            cloud.points.store("TEMP Before", field)
            cloud.points.offset = (ds, 0, 0)
            cloud.points.store("TEMP After", field)
            cloud.points.offset = (ds2_, 0, 0)

            cloud.points.store("TEMP dvx", Vector.Named("TEMP After") - Vector.Named("TEMP Before"))

        with Layout("Along Y"):
            cloud.points.offset = (0, ds2_, 0)
            cloud.points.store("TEMP Before", field)
            cloud.points.offset = (0, ds, 0)
            cloud.points.store("TEMP After", field)
            cloud.points.offset = (0, ds2_, 0)

            cloud.points.store("TEMP dvy", Vector.Named("TEMP After") - Vector.Named("TEMP Before"))

        with Layout("TEMP Along Z"):
            cloud.points.offset = (0, 0, ds2_)
            cloud.points.store("TEMP Before", field)
            cloud.points.offset = (0, 0, ds)
            cloud.points.store("TEMP After", field)
            cloud.points.offset = (0, 0, ds2_)

            cloud.points.store("TEMP dvz", Vector.Named("TEMP After") - Vector.Named("TEMP Before"))

        with Layout("Curl"):
            dvx, dvy, dvz = Vector.Named("TEMP dvx"), Vector.Named("TEMP dvy"), Vector.Named("TEMP dvz")
            curl = Vector((
                dvy.z - dvz.y,
                dvx.z - dvz.x,
                dvx.y - dvy.x,
            )).scale(scale)
            cloud.points.store("Vectors", curl.switch(normalize, curl.scale(1/ds)))

        cloud.remove_named_attribute("TEMP *", exact=False)

        cloud.out()

    # =============================================================================================================================
    # Compute the lines of field

    with GeoNodes("Lines of Field", prefix=util_prefix):

        # ----- Field

        field       = Vector(0, "Field", tip="Field vector at the input geometry points")

        # ----- Algorithm parameter

        iterations  = Integer(20, "Iterations", 1, tip="Number of iterations per line")
        delta       = Float(.1, "Delta", .001, tip="Distance to move at each iteration")
        direction   = Integer(1, "Direction",  tip="Move forwards (+1) or backwards (-1)")

        # ----------------------------------------------------------------------------------------------------
        # Main

        with Layout("Starting points"):
            geo = Geometry()
            mesh = geo.mesh.faces.delete_edges_and_faces() + geo.point_cloud.to_vertices()

            mesh.points.store("DELTA", delta*direction)

        with Repeat(mesh=mesh, top=True, iterations=iterations) as rep:

            mesh = rep.mesh

            with Layout("Displacement from current points"):
                v0 = field
                l0 = v0.length

                mesh.points[rep.top].store("Intensity", l0)

                rep.top &= l0.greater_than(0.001)

                v0 = v0.normalize().scale(Float.Named("DELTA"))

            with Layout("Extrude from this first displacement"):

                mesh = mesh.points[rep.top].extrude(offset=v0)
                top  = mesh.top_

            with Layout("Displacement from extruded point"):

                v1 = field
                v1 = v1.normalize().scale(Float.Named("DELTA"))
                v1 = (v1 - v0).scale(.5)

                mesh.points[top].offset = v1

            rep.top  = top
            rep.mesh = mesh

        mesh = rep.mesh
        mesh.remove_named_attribute("DELTA")

        curve = mesh.to_curve()
        curve.points.radius = gnmath.log(1 + Float.Named("Intensity"))

        curve.out("Curve")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electric Field

    with GeoNodes("Electrostatic", is_group=True, prefix=field_prefix):

        charges_loc = Geometry(None, "Charges Locations", tip="Charge locations")
        charges_val = Float(1, "Charges Values", tip="Electric charges")
        max_len     = Float(1000, "Max Length", 1, tip="Max field vector length")

        with Layout("Mesh or Points input"):
            cloud = charges_loc.point_cloud + charges_loc.mesh.points.to_points()
            count = cloud.points.count

        with Layout("Charge values"):
            charges_val = cloud.points.capture(charges_val)

        with Repeat(field=Vector(), index=0, iterations=count) as rep:

            charge_loc = cloud.points.sample_index(nd.position, index=rep.index)
            charge_val = cloud.points.sample_index(charges_val, index=rep.index)

            v = nd.position - charge_loc
            l = v.length
            l3 = gnmath.max(1/max_len, l**3)
            rep.field += charge_val*v/l3

            rep.index += 1

        rep.field.out("E")
        Vector().out("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a charge moving in an arbitray direction

    with GeoNodes("Moving Charge", is_group=True, prefix=field_prefix) as tree:

        charge_loc = Vector(0, "Charge Location", tip="Location of the moving charge")
        charge     = Float(1,  "Charge", tip="Value of the charge")
        speed      = Vector((.8, 0, 0), "Speed", tip="Speed of the moving charge as a percentage of speed of light.")
        max_len    = Float(1000, "Max Length", 1, tip="Max field vector length")

        with Layout("Ensure beta is not greater than 1"):
            length = speed.length
            beta   = gnmath.min(length, .999)
            speed  = speed.scale(beta/length)

        with Layout("Gamma"):
            gamma = 1/gnmath.sqrt(1 - beta**2)

        with Layout("Align speed along X axis"):
            rotation = Rotation.AlignXToVector(speed)
            inv_rot  = rotation.invert()

            rotated_position = inv_rot @ (nd.position - charge_loc)

        with Layout("Charge*gamma/rho**3"):
            rho = rotated_position.length
            gr3 = charge*gamma/rho**3

        with Layout("E and B in rotated frame"):
            E = gr3*rotated_position
            B = (gr3*beta)*Vector((0, -rotated_position.z, rotated_position.y))

        with Layout("Maximum length"):
            E = E.normalize().scale(gnmath.min(E.length, max_len))
            B = B.normalize().scale(gnmath.min(B.length, max_len))

        with Layout("Back to the initial frame"):
            E = rotation @ E
            B = rotation @ B

        E.out("E")
        B.out("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by charges along a curve

    with GeoNodes("Moving Charges on a Curve", is_group=True, prefix=field_prefix):

        source      = Curve(None, "Source Curve", tip="Curve on which charges are moving")
        count       = Integer(1, "Count", 1, 1000, tip="Number on charges on the curve")
        t           = Float(0, "t", tip="Time")
        charge      = Float(1, "Charge", tip="Charge value")
        beta        = Float(.8, "Beta", -.999, .999, tip="Charges speed in percentage of the speed of light")

        # ----------------------------------------------------------------------------------------------------
        # Main

        dt = 1/count
        centers = Cloud.Points(count=count)

        with Repeat(centers=centers, e=Vector(), b=Vector(), index=0, iterations=count) as rep:

            sample = source.sample(factor=abs(rep.index*dt + t) % 1)

            charge_loc   = sample.position_
            charge_speed = sample.tangent_.scale(beta)

            field_node = Group("Moving Charge", {
                'Charge Location': charge_loc,
                'Charge'         : charge/count,
                'Speed'          : speed,
                }, prefix=field_prefix)

            rep.e += field_node.e
            rep.b += field_node.b

            # ----- To visualize charges locations

            rep.centers.points[rep.index].position = charge_loc

            # ----- Next

            rep.index += 1

        rep.e.out("E")
        rep.b.out("B")
        rep.centers.out("Charge Locations")

    # =============================================================================================================================
    # Lorentz transformation for electromagnetic field

    with GeoNodes("EM Lorentz", is_group=True, prefix=util_prefix):

        speed = Vector((.8, 0, 0), "Speed")
        E     = Vector(0, "E")
        B     = Vector(0, "B")

        # ----- Make sure beta is ok

        with Layout("Ensure beta is not greater than 1"):
            length = speed.length
            beta   = gnmath.min(length, .999)
            speed  = speed.scale(beta/length)

        # ----- Rotate to have speed along x axis

        with Layout("Rotate fields to have speed long x axis"):

            rotation = Rotation.AlignXToVector(speed)
            inverse  = rotation.invert()

            E_rot = inverse @ E
            B_rot = inverse @ B

        # ----- Lorentz transformation

        with Layout("Lorentz transformation"):

            gamma = (1 - beta**2)**(-.5)

            Erx, Ery, Erz = E_rot.x, E_rot.y, E_rot.z
            Brx, Bry, Brz = B_rot.x, B_rot.y, B_rot.z

            E_rot_ = Vector((Erx, gamma*(Ery - beta*Brz), gamma*(Erz + beta*Bry)))
            B_rot_ = Vector((Brx, gamma*(Bry + beta*Erz), gamma*(Brz - beta*Ery)))

        # ----- Rotate back

        with Layout("Rotate back"):
            E_ = rotation @ E_rot_
            B_ = rotation @ B_rot_

        # ----- Done

        E_.out("E")
        B_.out("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoid

    with GeoNodes("Solenoid", is_group=True, prefix=field_prefix):

        charge      = Float(1,    "Charge", tip="Total charge of the solenoid")
        beta        = Float(.8,   "Beta", -.999, .999, tip="Speed in percentage of the speed of light")
        R           = Float(1,    "Radius",  .1, 10, tip="Solenoid radius")
        loops       = Integer(10, "Loops", 1, tip="Number of loops")
        length      = Float(5,    "Length", .1, 10, tip="Solenoid length")

        with Layout("Position converted to cylindrical coordinates along x"):
            pos = nd.position
            x = pos.x._lc("x")
            r = Vector((0, pos.y, pos.z)).length._lc("r")
            lam = gnmath.atan2(pos.z, pos.y)._lc("lambda")
            cos_lam = (pos.y/r)._lc("cos lambda")
            sin_lam = (pos.z/r)._lc("sin lambda")

        with Layout("Number of charges on a each loop"):
            count = round(R*32)._lc("Count")
            circle = Mesh.Circle(vertices=count, radius=1)

        with Layout("Split Solenoid length in loops"):
            xs0 = (-length/2)._lc("xs0")
            dxs = (length/gnmath.max(1, loops-1))._lc("dxs")

        # ----------------------------------------------------------------------------------------------------
        # Loop on theta

        with Repeat(ex=0., er=0., bx=0., br=0., index=0, iterations=count) as rep_theta:

            cs = circle.points.sample_index(nd.position, index=rep_theta.index)
            cos_theta, sin_theta = (cs.x)._lc("cos theta"), cs.y._lc("sin theta")

            with Layout("Once : R2sin2 + (r - Rcos)2"):
                rho_cst = (R*sin_theta)**2 + (r - R*cos_theta)**2

            # ----------------------------------------------------------------------------------------------------
            # Loop on solenoids loops

            with Repeat(ex=rep_theta.ex, er=rep_theta.er, bx=rep_theta.bx, br=rep_theta.br, index=0, iterations=loops) as rep_xs:

                x_s = gnmath.multiply_add(rep_xs.index, dxs, xs0)._lc("x_s")
                rep_xs.index += 1

                with Layout("1/Rho**3"):
                    rho3 = (((x - x_s)**2 + rho_cst)**(-1.5))._lc("1/rho**3")

                with Layout("Ex"):
                    rep_xs.ex += (x - x_s)*rho3

                with Layout("Er"):
                    rep_xs.er += (r - R*cos_theta)*rho3

                with Layout("Bx"):
                    rep_xs.bx += (R - r*cos_theta)*rho3

                with Layout("Br"):
                    rep_xs.br += (x - x_s)*cos_theta*rho3

            # ----- Next loop

            rep_theta.ex += rep_xs.ex
            rep_theta.er += rep_xs.er
            rep_theta.bx += rep_xs.bx
            rep_theta.br += rep_xs.br

            rep_theta.index += 1

        # ----------------------------------------------------------------------------------------------------
        # Finalize the fields

        with Layout("-2*gamma*charge"):
            gam_charge = (-2*charge/count/loops)*(1 - beta**2)**(-0.5)

        with Layout("Electric Field"):
            E = Vector((
                rep_theta.ex,
                rep_theta.er*cos_lam,
                rep_theta.er*sin_lam,
            )).scale(gam_charge)

        with Layout("Magnetic Field"):
            B = Vector((
                rep_theta.bx,
                rep_theta.br*cos_lam,
                rep_theta.br*sin_lam,
            )).scale(gam_charge*beta)

        E.out("E")
        B.out("B")

    # ----------------------------------------------------------------------------------------------------
    # Magnet field

    with GeoNodes("Magnet", is_group=True, prefix=field_prefix):

        width_scale  = Float(1., "Width Scale",  0.01, tip="Width scale")
        location     = Vector(0, "Location", tip="Magnet location")
        rotation     = Rotation(0, "Rotation", tip="Magnet rotation")
        speed        = Vector(0, "Speed", tip="Magnet speed in percentage of the speed of light")

        # ----- Computation is made for a magnet centered along the x axis

        with Layout("Center Magnet and align along x"):
            position = rotation.invert() @ (nd.position - location)
            x, y, z = position.x, position.y, position.z

        # ----- Plane passing through x axis

        with Layout("Plane containing point and x axis"):
            angle = gnmath.atan2(z, y)
            rot_y = gnmath.sqrt(y**2 + z**2)

        # ----- Width scale

        y_ = rot_y/width_scale

        # ----- Normalized radius

        r = (x**2 + y_**2)/2/y_

        # ----- Normalized B

        B = Vector(((r - y_)/width_scale, x, 0)).normalize()

        # ----- Rotation

        B = Rotation((angle, 0, 0)) @ B

        # ----- Back to the initial frame

        B = rotation @ B

        with Layout("Take speed into account"):

            transf_node = Group("EM Lorentz", {'Speed': speed, 'B': B}, prefix=util_prefix)
            E = transf_node.e
            B = transf_node.b

        # ----- Done

        E.to_output("E")
        B.to_output("B")

    # =============================================================================================================================
    # Points in space where to compute the fields

    with GeoNodes("Source Points", prefix=util_prefix):

        location    = Vector(0,         "Location")
        size        = Vector((5, 5, 5), "Size")
        density     = Float(1,          "Density")
        rotation    = Rotation(0,       "Rotation")
        max_dist    = Float(100,        "Max Distance", 1, tip="Remove points farther than maximum distance to the center")
        center      = Vector(0,         "Center for Max Distance", tip="Center to compute maximum distance")
        seed        = Integer(0,        "Seed")

        geo = Geometry()

        with Layout("Points on faces"):
            pts_faces_cloud = Mesh(geo).faces.distribute_points(density=density, seed=seed)

        with Layout("Points in volume"):
            pts_vol_cloud = Mesh(geo).to_volume(density=density).distribute_points(seed=seed)

        with Layout("Plane"):
            grid = Mesh.Grid(size.x, size.y, 2, 2)
            plane_cloud = grid.faces.distribute_points(density=density, seed=seed)

        with Layout("Disk"):
            disk = Mesh.Disk()
            disk = disk.transform(scale=(size.x, size.y, 1))
            disk_cloud = disk.faces.distribute_points(density=density, seed=seed)

        with Layout("Cube"):
            cube = Mesh.Cube(size)
            cube_cloud = cube.to_volume(density=density).distribute_points(seed=seed)

        with Layout("Cylinder"):
            cyl = Mesh.Cylinder(depth=1)
            cyl = cyl.transform(scale=(size.x, size.y, size.z))
            cyl_cloud = cyl.to_volume(density=density).distribute_points(seed=seed)

        with Layout("Sphere"):
            sphere = Mesh.UVSphere()
            sphere = sphere.transform(scale=(size.x, size.y, size.z))
            sphere_cloud = sphere.to_volume(density=density).distribute_points(seed=seed)

        cloud = Cloud.MenuSwitch(items={
            'Input Geometry'   : Cloud(geo),
            'Points on faces'  : pts_faces_cloud,
            'Points in volume' : pts_vol_cloud,
            'Plane'            : plane_cloud,
            'Disk'             : disk_cloud,
            'Cube'             : cube_cloud,
            'Cylinder'         : cyl_cloud,
            'Sphere'           : sphere_cloud,
        }, menu='Cube', name='Shape')

        cloud = cloud.transform(translation=location, rotation=rotation)
        cloud = cloud.points[nd.position.distance(center).greater_than(max_dist)].delete()

        cloud.out()

    # =============================================================================================================================
    # Visualize some of the fields

    with GeoNodes("Field", prefix=show_prefix):

        field = Vector(0, "Field", tip="Field to visualize")

        cloud = Cloud()

        with Layout("Arrows:"):

            show_arrows = Boolean(True, "Show arrows")

            arrows_group = Group("Arrows", {'Geometry': cloud, 'Vectors': field})
            arrows_group.plug_node_into(include=['Scale', 'Logarithm'], rename={'Color': 'Arrow Color'})
            arrows_mat = Material("Arrows", "Arrows Material")
            arrows_group.shaft = arrows_mat
            arrows_group.head= arrows_mat
            arrows = arrows_group._out

        with Layout("Lines of field computation"):
            lines_group = Group("Lines of Field", {
                'Geometry': cloud,
                'Field': field,
                'Direction': Integer.Random(0, 1, seed=0)*2 - 1,
            }, prefix=util_prefix)
            curves = Curve(lines_group._out)

        with Layout("Lines of field as mesh"):
            show_lines = Boolean(False, "Lines of Field")
            lines_color = Color(None, "Lines Color")
            curves.points.store("Color", lines_color)
            curves.points.store("Transparency", 1 - lines_color.alpha)

            mesh_curves = curves.to_mesh(profile_curve=Curve.Circle(radius=Float(.02, "Lines Section", 0)), fill_caps=True)
            mesh_curves.faces.smooth = True
            mesh_curves.faces.material = Material(None, "Lines material")

        with Layout("Arrows on lines of field"):
            show_lines_arrows = Boolean(False, "Arrows on Lines")
            lar_delta = Float(.5, "Interval",.1, tip="Distance between arrows on the lines of field")
            lar_scale = Float(1., "Lines Arrows Scale",.01, tip="Scale of arrows on the lines of field")
            lar_origins = curves.resample(length=gnmath.max(.1, lar_delta))
            lar_vectors = lar_origins.tangent.scale(Float.Named("Intensity")*lar_scale)

            lar_group = Group("Arrows", {'Geometry': lar_origins, 'Vectors': lar_vectors})
            lar_group.plug_node_into(include=[], rename={'Logarithm': 'Lines Arrows Log', 'Color': 'Lines Arrows Color'})

            lar_arrows = lar_group._out

        geo = Mesh.Switch(show_arrows, None, arrows)
        geo += Mesh.Switch(show_lines, None, mesh_curves)
        geo += Mesh.Switch(show_lines_arrows, None, lar_arrows)

        geo.out()

    # =============================================================================================================================
    # Visualize some of the fields

    with GeoNodes("Visualize some fields"):

        # ----------------------------------------------------------------------------------------------------
        # Source points

        source_node = Group("Source Points", prefix=util_prefix)
        source_node.plug_node_into(include=['Size', 'Density', 'Seed', 'Shape'])
        cloud = source_node._out

        use_magnetic = Boolean(False, "Magnetic Field", tip="Magnetic field if True, electric field otherwise")

        with Layout("Static Electric field from charges"):
            node = Group("Electrostatic",{
                'Charges Locations' : Cloud.Points(count=6, position=Vector.Random(-1, 1, seed=100+seed)),
                'Charges Values'    : Float.Random(-1, 1, seed=101+seed),
                }, prefix=field_prefix)
            static_field = node.e.switch(use_magnetic, node.b)

        with Layout("Moving charge"):
            node = Group("Moving Charge", prefix=field_prefix)
            moving_field = node.e.switch(use_magnetic, node.b)

        with Layout("Solenoid"):
            node = Group("Solenoid", prefix=field_prefix)
            solenoid_field = node.e.switch(use_magnetic, node.b)

        with Layout("Magnet"):
            node = Group("Magnet", prefix=field_prefix)
            magnet_field = node.e.switch(use_magnetic, node.b)


        field = Vector.MenuSwitch({
            'Electrostatic' : static_field,
            'Moving charge' : moving_field,
            'Solenoid'      : solenoid_field,
            'Magnet'        : magnet_field,
            }, menu=0, name='Field', tip="Field to visualize")

        show_node = Group("Field", {
            'Geometry': cloud,
            'Field': field,
        }, prefix=show_prefix)

        show_node.plug_node_into()
        geo = show_node._out

        geo.out()














    return








# =============================================================================================================================
# Visualize a field computed by a group
#
# The group must take the following input nodes
#
# - Position     : locations where to compute the field
# - kwargs       : kwargs passed in the function

def gen_field_visualization(tree, field_node):

    # ----- Visualisation parameters

    elec_field  = tree.bool_input(  "Electric field",       True, description="Show electric field rather than magnetic field")
    color       = tree.color_input( "Color",                (0., 0., 1., 1.), description="'Color' named attribute to pass to the shader")
    transp      = tree.factor_input("Transparency",         0., min_value=0., max_value=1, description="'Transparency' named attribute to pass to the shader")

    # ----- Arrows

    scale       = tree.float_input( "Scale",                1., min_value=0., description="Vectors multiplicator")
    curl_vect   = tree.bool_input(  "Curl Vectors",         False, description="Use curl shape for arrows")

    # ----- Lines of field

    field_lines = tree.bool_input(  "Lines of field",       False, description="Lines of field (True) or field of vectors (False)")
    iterations  = tree.int_input(   "Iterations",           20, min_value=1, description="Number of iterations to compute the lines of field")
    delta       = tree.float_input( "Delta",                .1, min_value=.001, description="Distance to move at each iteration")
    int_fac     = tree.factor_input("Intensity",            .9, min_value=0., max_value=1., description="Use intensity named attribute for radius")
    rand_dir    = tree.bool_input(  "Random Direction",     False, description="Build lines in random directions rather than in both directions")

    # ----- Geometry parameters

    resol       = tree.int_input(     "Resolution",         12, min_value=3, max_value=64, description="Lines / arrows section resolution")
    section     = tree.float_input(   "Section",            .02, min_value=0., max_value=1., description="Lines / arrows section")
    material    = tree.material_input("Material",           "Arrow", description="Arrows / lines material")

    # ----- Show / Hide

    show        = tree.bool_input(    "Show",               True, description="Show / hide flag")

    # ====================================================================================================
    # Utilities

    def get_field():
        return field_node.b.switch(elec_field, field_node.e)

    def build_lines(points, direction):
        return tree.group("Compute Lines of Field",
            geometry    = points,
            field       = get_field(),
            iterations  = iterations,
            delta       = delta,
            direction   = direction,
            ).geometry

    # ====================================================================================================
    # Main

    with Layout("Starting points"):
        comps_node = tree.geometry.separate_components()
        points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
        points = points.points_to_vertices()

    # ----------------------------------------------------------------------------------------------------
    # Arrows

    with Layout("Arrows"):

        points.store_named_vector("Vectors", get_field())

        arrows = tree.group("Arrows", points,
            scale         = scale,
            resolution    = resol,
            section       = section,
            sphere        = curl_vect,
            color         = color,
            transparency  = transp,
            shaft         = material,
            head          = material,
            ).geometry

    # ----------------------------------------------------------------------------------------------------
    # Lines of field

    with Layout("Lines of field"):
        curves  = build_lines(points, 1)
        curves += build_lines(points, -1)

        curves = curves.switch(rand_dir, build_lines(points, tree.integer(1).switch(tree.random_boolean(.5), -1)))

        lines = tree.group("To Lines of Field",
                geometry         = curves,
                resolution       = resol,
                radius           = section,
                intensity_factor = int_fac,
                transparency     = transp,
                color            = color,
                material         = material,
                ).geometry

    mesh = arrows.switch(field_lines, lines)

    # ----- Done

    return mesh.switch(-show)

# =============================================================================================================================
# Build function

def build_fields(clear_sockets=False):

    arrows_module.build_arrows()











    # =============================================================================================================================
    # Visualize spheres on points

    def gen_spheres_on_charges(tree, charges_loc):

        sph_radius   = tree.float_input(   "Spheres Radius",   .1, min_value=0., description="Spheres radius (0 if charges must not be visualized)")
        sph_color    = tree.color_input(   "Spheres Color", description="Spheres 'Color' named attribute to pass to the Shader")
        sph_mat      = tree.material_input("Spheres Material", description="Spheres material")

        with Layout("Spheres on charges"):
            charges_loc.store_named_vector("Color", sph_color)
            spheres = charges_loc.instance_on_points(instance=tree.UVSphere(radius=sph_radius).mesh)
            spheres = spheres.realize_instances()
            spheres.FACE.shade_smooth = True
            spheres.FACE.material = sph_mat

        return spheres.switch(sph_radius.equal(0))

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("Electric Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charges_obj = tree.object_input("Charges location", 1., description="Geometry proving the locations of the charges")
        charge_min  = tree.float_input( "Min Charge", -1., description="Minimum value for electric charge")
        charge_max  = tree.float_input( "Max Charge",  1., description="Maximum value for electric charge")
        seed = tree.int_input(          "Seed",        0,  description="Random seed")

        # ----- Main

        charges = charges_obj.object_info().geometry
        charges.POINT.store_named_float("Charge", tree.random_float(min=charge_min, max=charge_max, seed=seed))

        field_node = tree.group("G Electric Field",
            position = tree.position,
            charges  = charges,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, charges)

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("X Moving Charge Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charge      = tree.float_input(  "Charge", 1., description="Value of the charge")
        beta        = tree.float_input(  "Beta",   0, min_value=-.999, max_value=.999, description="Beta relativist speed")
        t           = tree.float_input(  "t", description="Time")
        max_len     = tree.float_input(  "Max Lengh", 1., description="Max Vectors Length")

        # ----- Main

        field_node = tree.group("G X Moving Charge Field",
            position   = tree.position,
            charge     = charge,
            beta       = beta,
            t          = t,
            max_length = max_len,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, tree.Points(count=1, position=(beta*t, 0, 0)).points)
        field_node.charge_location.to_output("Charge location")

    # ----------------------------------------------------------------------------------------------------
    # A charge moving in an arbitrary direction

    with gn.GeoNodes("Moving Charge Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charge_loc  = tree.vector_input( "Charge location", description="Charge location")
        charge      = tree.float_input(  "Charge",  1., description="Value of the charge")
        speed       = tree.vector_input( "Speed", (.8, 0, 0), description="Charge speed (length must be less than 1)")

        # ----- Main

        field_node = tree.group("G Moving Charge Field",
            position        = tree.position,
            charge_location = charge_loc,
            speed           = speed,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, tree.Points(count=1, position=charge_loc).points)

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by several charges

    with gn.GeoNodes("Charges on Curve Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters0

        source_curve = tree.object_input(  "Source Curve", description="Curve on which charges are moving")
        count        = tree.int_input(     "Charges count",    10, min_value=1, max_value=1000, description="Number of charges")
        t            = tree.float_input(   "t",                0., description="Time for charges animation")
        charge       = tree.float_input(   "Charge",           1., description="Total charge")
        beta         = tree.float_input(   "Beta",             .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        sph_radius   = tree.float_input(   "Spheres Radius",   .1, min_value=0., description="Charges sphere radius (0 if charges must not be visualized)")
        sph_mat      = tree.material_input("Spheres Material", description="Charges material")

        # ----- Main

        curve = source_curve.object_info().geometry

        field_node = tree.group("G Charges on Curve Field",
            position        = tree.position,
            source_curve    = curve,
            count           = count,
            t               = t,
            charge          = charge,
            beta            = beta,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with Layout("Spheres"):

            sph_locs = field_node.charge_locations
            spheres = sph_locs.instance_on_points(instance=tree.UVSphere(radius=sph_radius).mesh)
            spheres.FACE.shade_smooth = True
            spheres.FACE.material = sph_mat

        tree.geometry = field_visu + spheres.switch(sph_radius.equal(0))

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoide

    with gn.GeoNodes("Solenoid Field", clear_sockets=clear_sockets) as tree:

        charge      = tree.float_input(  "Charge",      1., description="Total charge")
        beta        = tree.float_input(  "Beta",        .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        radius      = tree.float_input(  "Radius",      1., min_value=.1, max_value=10, description="Solenoid radius")
        length      = tree.float_input(  "Length",      5., min_value=.1, max_value=10, description="Solenoid length")

        # ---- Solenoid

        wire_radius  = tree.float_input(   "Wire radius", .1, min_value=.001, description="Radius of the wire (0 for no visualization)")
        wire_mat     = tree.material_input("Wire Material", description="Wire material")

        # ----- Main

        field_node = tree.group("G Solenoid Field",
            position        = tree.position,
            charge          = charge,
            beta            = beta,
            radius          = radius,
            length          = length,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with Layout("Solenoid"):

            loops = tree.min(30, tree.max(1, length/2/wire_radius))

            wire_curve = tree.Spiral(
                #resolution      = 32,
                rotations       = loops,
                start_radius    = radius,
                end_radius      = radius,
                height          = length,
                ).curve

            wire_curve.transform_geometry(translation=(-length/2, 0, 0), rotation=(0, np.pi/2, 0))

            wire = wire_curve.curve_to_mesh(profile_curve=tree.CurveCircle(radius=wire_radius, resolution=12).curve)

            wire.FACE.shade_smooth = True
            wire.FACE.material     = wire_mat

        tree.geometry = field_visu + wire.switch(wire_radius.equal(0))

    # =============================================================================================================================
    # Magnet

    # -----------------------------------------------------------------------------------------------------------------------------
    # A single magnetic loop from a magnet
    #
    # Loop is an ellipsis tangent to x axis defined by its length (along x)
    # and width scale (along y)

    with gn.GeoNodes("Magnet Single Loop", clear_sockets=clear_sockets) as tree:

        length      = tree.float_input("Length", 1., min_value=0.)
        width_scale = tree.float_input("Width Scale",  1., min_value=0.01)
        angle       = tree.angle_input("Angle",  0.)
        count       = tree.int_input(  "Resolution", 32, min_value=3)

        # ----- Main

        width = length * width_scale

        circle = tree.MeshCircle(vertices=count, radius=1).mesh
        x, y = tree.position.x, tree.position.y
        circle.POINT.store_named_float("Intensity", (1.01 - y)*length)

        x = tree.position.x * length
        y = tree.position.y * width + width
        z = tree.position.z

        circle.POINT.position = tree.vector((x, y, z))
        circle.transform_geometry(rotation=(angle, 0, 0))

        tree.geometry = circle.mesh_to_curve()

    # -----------------------------------------------------------------------------------------------------------------------------
    # Magnet loops
    #
    # Compute the magnetic field loops from the points in the input geometry
    #
    # Given x, y, what is r such as:
    # x^ + (y - r)^2 = r^2
    # r = (x^2 + y^2)/2y

    with gn.GeoNodes("Magnet Loops", clear_sockets=clear_sockets) as tree:

        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01)
        location     = tree.vector_input(  "Location")
        rotation     = tree.rotation_input("Rotation")

        # ----- Input points

        with Layout("Input points"):
            comps = tree.geometry.separate_components()
            points = comps.point_cloud + comps.mesh.mesh_to_points()
            n = points.CLOUD.domain_size().point_count

        # ----- Computation is made for a magnet centered along the x axis

        with Layout("Center Magnet and align along x"):
            points.POINT.position = (tree.position - location).rotate_vector(rotation.clone.invert_rotation())

        # ----- Loop on the input points

        with tree.repeat(geometry=None, index=0, iterations=n) as rep:

            p = points.sample_index_vector(index=rep.index, value=tree.position)
            rep.index += 1

            x, y, z = p.x, p.y, p.z

            # ----- Plane passing through x axis

            angle = tree.arctan2(z, y)
            rot_y = tree.sqrt(y**2 + z**2)

            # ----- Width scale

            y_ = rot_y/width_scale

            r = (x**2 + y_**2)/2/y_

            # ----- Add a loop

            rep.geometry += tree.group("Magnet Single Loop",
                length      = r,
                width_scale = width_scale,
                angle       = angle,
                resolution  = 20 + r*20,
                ).geometry

        with Layout("Back to initial frame"):
            curves = rep.geometry
            curves.POINT.position = location + tree.position.rotate_vector(rotation)

        # ----- Done

        tree.geometry = curves

    # ----------------------------------------------------------------------------------------------------
    # Magnet field

    with gn.GeoNodes("G Magnet Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position     = tree.vector_input(  "Position")
        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01)
        location     = tree.vector_input(  "Location")
        rotation     = tree.rotation_input("Rotation")
        speed        = tree.vector_input(  "Speed")

        # ----- Computation is made for a magnet centered along the x axis

        with Layout("Center Magnet and align along x"):
            position = (position - location).rotate_vector(rotation.clone.invert_rotation())

            x, y, z = position.x, position.y, position.z

        # ----- Plane passing through x axis

        with Layout("Plane containing point and x axis"):
            angle = tree.arctan2(z, y)
            rot_y = tree.sqrt(y**2 + z**2)

        # ----- Width scale

        y_ = rot_y/width_scale

        # ----- Normalized radius

        r = (x**2 + y_**2)/2/y_

        # ----- Normalized B

        B = tree.vector(((r - y_)/width_scale, x, 0)).normalize()

        # ----- Rotation

        B = B.rotate_vector(rotation=(angle, 0, 0))

        # ----- Back to the initial frame

        B = B.rotate_vector(rotation)

        with Layout("Take speed into account"):

            transf_node = tree.group("EM Lorentz", speed=speed, b=B)
            E = transf_node.e
            B = transf_node.b

        # ----- Done

        E.to_output("E")
        B.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Magnet Shape

    with gn.GeoNodes("Magnet Shape", clear_sockets=clear_sockets) as tree:

        location     = tree.vector_input(   "Location")
        rotation     = tree.rotation_input( "Rotation")

        # ----- Magnet shape

        round_profile = tree.bool_input(    "Round Profile", False)
        magnet_length = tree.float_input(   "Length", 1.)
        profile_size  = tree.float_input(   "Profile Size",  .3)
        profile_scale = tree.float_input(   "Profile Scale", .8)
        material      = tree.material_input("Material")
        show          = tree.bool_input(    "Show",           True)

        # ----- Magnet shape

        rect = tree.Grid(size_x=profile_size, size_y=profile_size*profile_scale, vertices_x=2, vertices_y=2).mesh.mesh_to_curve()
        ell  = tree.CurveCircle(radius=profile_size/2).curve.transform_geometry(scale=(1, profile_scale, 1))

        prof = rect.switch(round_profile, ell)
        prof.POINT.store_named_float("uvy", tree.spline_parameter.factor)

        base = tree.CurveLine(start=(magnet_length*(-.5), 0, 0), end=(magnet_length*.5, 0, 0)).curve
        base.POINT.store_named_float("uvx", tree.spline_parameter.factor)

        shape = base.curve_to_mesh(profile_curve=prof, fill_caps=True)
        shape.CORNER.store_named_vector("UVMap", tree.vector((shape.named_float("uvx"), shape.named_float("uvy"), 0)))
        shape.FACE.shade_smooth = False
        shape.FACE.material     = material

        shape = shape.transform_geometry(translation=location, rotation=rotation)

        tree.geometry = shape.switch(-show)

    # =============================================================================================================================
    # A full Magnet

    with gn.GeoNodes("Magnet", clear_sockets=clear_sockets) as tree:

        #raise tree.Break()

        # ----- Magnet specs

        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01, description="Magnet field scale")
        location     = tree.vector_input(  "Location", description="Magnet location")
        rotation     = tree.rotation_input("Rotation", description="Magnet rotation")
        speed        = tree.vector_input(  "Speed",    description="Magnet speed")

        # ----- Magnet shape

        show_magnet   = tree.bool_input(    "Show Magnet")
        round_profile = tree.bool_input(    "Round Profile", False)
        magnet_length = tree.float_input(   "Length", 1.)
        profile_size  = tree.float_input(   "Profile Size",  .3)
        profile_scale = tree.float_input(   "Profile Scale", .8)
        magnet_mat    = tree.material_input("Magnet Material")

        # ----- Magnetic loops

        show_loops   = tree.bool_input(     "Show Magnetic Loops", True)
        loop_int_fac = tree.factor_input(   "Mag Lines Intensity", 1., min_value=0., max_value=1.)
        loop_section = tree.float_input(    "Mag Lines Section", .02, min_value=0., max_value=1.)
        min_loop_sec = tree.float_input(    "Min Mag Lines Section", 0, min_value=0., max_value=1.)
        loop_color   = tree.color_input(    "Mag Lines Color", (0, 1, 0, 1))
        loop_transp  = tree.factor_input(   "Mag Lines Transparency", 0., min_value=0., max_value=1.)
        loop_mat     = tree.material_input( "Mag Lines Material", "Arrow")

        loop_arrows  = tree.bool_input(     "Show Loops Arrows",    True)
        ar_scale     = tree.float_input(    "Scale",                1., min_value=0.)
        ar_dist      = tree.float_input(    "Distance",             .5, min_value=.1, )
        ar_section   = tree.float_input(    "Section",              .02, min_value=0., max_value=1.)
        ar_color     = tree.color_input(    "Color",                (0, 1, 0, 1))
        ar_transp    = tree.factor_input(   "Transparency",         0., min_value=0., max_value=1.)
        ar_mat       = tree.material_input( "Material",             "Arrow")

        # ----- Magnetic Arrows

        show_arrows  = tree.bool_input(     "Show Arrows",    True)

        # ----- Electric Field

        eshow_field   = tree.bool_input(     "Show Electric Field", False)
        e_max_dist    = tree.float_input(    "Max Distance to Magnet")
        eloop_int_fac = tree.factor_input(   "Elec Lines Intensity", 1., min_value=0., max_value=1.)
        eloop_section = tree.float_input(    "Elec Lines Section", .02, min_value=0., max_value=1.)
        min_eloop_sec = tree.float_input(    "Min Elec Lines Section", 0, min_value=0., max_value=1.)
        eloop_color   = tree.color_input(    "Elec Lines Color", (1, 0, 1, 1))
        eloop_transp  = tree.factor_input(   "ELec Lines Transparency", 0., min_value=0., max_value=1.)
        eloop_mat     = tree.material_input( "Elec Lines Material", "Arrow")

        eloop_arrows  = tree.bool_input(     "Show Elec Line Arrows",    False)

        ef_iterations = tree.int_input(      "Iterations", 20, min_value=2)
        ef_delta      = tree.float_input(    "Delta",      .1, min_value=0.001)

        ear_scale     = tree.float_input(    "Elec Scale",                1., min_value=0.)
        ear_dist      = tree.float_input(    "Elec Distance",             .5, min_value=.1, )
        ear_section   = tree.float_input(    "Elec Section",              .02, min_value=0., max_value=1.)
        ear_color     = tree.color_input(    "Elec Color",                (1, 0, 1, 1))
        ear_transp    = tree.factor_input(   "Elec Transparency",         0., min_value=0., max_value=1.)
        ear_mat       = tree.material_input( "Elec Material",             "Arrow")

        eshow_arrows  = tree.bool_input(     "Show Elec Arrows",    False)

        # ----- Main

        field_node = tree.group("G Magnet Field",
            position     = tree.position,
            width_scale  = width_scale,
            location     = location,
            rotation     = rotation,
            speed        = speed,
            )

        # ----- Magnet shape

        geo = tree.group("Magnet Shape",
                    location      = location,
                    rotation      = rotation,
                    round_profile = round_profile,
                    length        = magnet_length,
                    profile_size  = profile_size,
                    profile_scale = profile_scale,
                    material      = magnet_mat,
                    show          = show_magnet,
                    )

        # ----- Magnetic Field loops

        with Layout("Magnet loops"):

            loops_node = tree.group("Magnet Loops",
                geometry     = tree.geometry,
                width_scale  = width_scale,
                location     = location,
                rotation     = rotation,
            )

            lines_mesh = tree.group("Field Curve to Mesh",
                geometry           = loops_node.geometry,
                show_lines         = show_loops,
                intensity          = loop_int_fac,
                lines_section      = loop_section,
                min_lines_section  = min_loop_sec,
                lines_color        = loop_color,
                lines_transparency = loop_transp,
                lines_material     = loop_mat,

                show_arrows        = loop_arrows,
                scale              = ar_scale,
                distance           = ar_dist,
                section            = ar_section,
                color              = ar_color,
                transparency       = ar_transp,
                material           = ar_mat,
            ).geometry

            geo += lines_mesh

        # ----- Arrows

        with Layout("Arrows"):

            points = tree.geometry
            points.POINT.store_named_vector("Vectors", field_node.b)

            arrows = tree.group("Arrows",
                geometry     = points,
                scale        = ar_scale,
                section      = ar_section,
                color        = ar_color,
                transparency = ar_transp,
                shaft        = ar_mat,
                head         = ar_mat,
                show         = show_arrows,
                ).geometry

            geo += arrows

        # ----- Electric field

        with Layout("Electric Field"):

            elec_field_node = tree.group("Compute Lines of Field",
                geometry     = tree.geometry,
                field        = field_node.e,
                iterations   = ef_iterations.switch(tree.is_viewport, ef_iterations/10),
                delta        = ef_delta.switch(tree.is_viewport, ef_delta*10),
                direction    = tree.float(-1).switch(tree.random_boolean(probability=.5), 1),
                origin       = location,
                max_distance = e_max_dist,
            )

            lines_mesh = tree.group("Field Curve to Mesh",
                geometry           = elec_field_node.geometry,
                show_lines         = eshow_field,
                intensity          = eloop_int_fac,
                lines_section      = eloop_section,
                min_lines_section  = min_eloop_sec,
                lines_color        = eloop_color,
                lines_transparency = eloop_transp,
                lines_material     = eloop_mat,

                show_arrows        = eloop_arrows,
                scale              = ear_scale,
                distance           = ear_dist,
                section            = ear_section,
                color              = ear_color,
                transparency       = ear_transp,
                material           = ear_mat,
            ).geometry

            geo += lines_mesh

        # ----- Arrows

        with Layout("Electric Arrows"):

            points = tree.geometry
            points.POINT.store_named_vector("Vectors", field_node.e)

            arrows = tree.group("Arrows",
                geometry     = points,
                scale        = ear_scale,
                section      = ear_section,
                color        = ear_color,
                transparency = ear_transp,
                shaft        = ear_mat,
                head         = ear_mat,
                show         = eshow_arrows,
                ).geometry

            geo += arrows

        # ----- Done

        tree.geometry = geo

    # =============================================================================================================================
    # Quick Solenoid

    # -----------------------------------------------------------------------------------------------------------------------------
    # A single loop

    with gn.GeoNodes("Solenoid Single Magnetic Loop") as tree:

        position = tree.vector_input("Position")

        radius = tree.float_input("Radius", 1., min_value=.1)
        length = tree.float_input("Length", 5., min_value=.1)

        length_factor = tree.float_input("Length factor", 1.2, min_value=0)
        radial_factor = tree.float_input("Radial factor", 1.2, min_value=0)

        with Layout("Cylindrical coordinates"):
            x, y, z = position.x, position.y, position.z
            rho   = tree.vector((0, y, z)).length()
            theta = tree.arctan2(z, y)

        with Layout("Circle Radius to match length along X"):
            radius_x = rho.map_range(from_min=0, from_max=radius, to_min=(radius + length)*length_factor, to_max=0)

        with Layout("Base Circle"):
            circle=tree.curve_circle(radius=1, resolution=12 + radius_x*20)

        with Layout("Intensity"):
            cy = tree.position.y
            circle.POINT.store_named_float("Intensity", 1.01 - cy)


        with Layout("Deform along Y"):
            scale_y = rho.map_range(from_min=0, from_max=radius, to_min=radial_factor, to_max=0)
            radius_y = radius_x*scale_y
            circle = circle.transform_geometry(translation=(0, rho + radius_y, 0), scale=(radius_x, radius_x*scale_y, 1))

        circle = circle.transform_geometry(rotation=(theta, 0, 0))

        tree.geometry = circle

    # -----------------------------------------------------------------------------------------------------------------------------
    # A full magnetic field from a Solenoid

    with gn.GeoNodes("Solenoid Magnetic Field") as tree:

        density = tree.float_input(   "Density", 10, min_value= 0.)
        seed    = tree.integer_input( "Seed",    0)
        radius  = tree.float_input(   "Radius",  1., min_value=.1)
        length  = tree.float_input(   "Length",  5., min_value=.1)

        length_factor = tree.float_input("Length factor", 1.2, min_value=0)
        radial_factor = tree.float_input("Radial factor", 1.2, min_value=0)


        with Layout("Random source point"):
            disk = tree.MeshCircle(radius=radius, fill_type='NGON').mesh
            disk.transform_geometry(rotation=(0, gn.half_pi, 0))

            points = disk.distribute_points_on_faces(density_max=density*10, density_factor=density, seed=seed, distribute_method='POISSON', distance_min=radius/10).points
            count = points.CLOUD.domain_size().point_count


        with tree.repeat(geometry=None, index = 0, iterations=count) as rep:

            with Layout("Current point"):
                position = points.sample_index_vector(value=tree.position, index=rep.index)

            circle = tree.group("Solenoid Single Magnetic Loop",
                position = position,
                radius = radius,
                length = length,
                length_factor = length_factor,
                radial_factor = radial_factor,
                ).geometry

            rep.geometry += circle
            rep.index += 1

        circles = rep.geometry

        mesh = tree.group("Field Curve to Mesh",
            geometry            = circles,
            show_lines          = tree.bool_input("Show circles"),
            lines_section       = 0.02,
            lines_color         = tree.color_input("Circle Color"),
            lines_transparency  = tree.factor_input("Circles_transparency", min_value=0, max_value=1),
            show_arrows         = tree.bool_input("Show Arrows"),
            distance            = tree.float_input("Distance", .1, min_value=0.0001),
            scale               = tree.float_input("Scale", 1.),
            color               = tree.color_input("Color"),
            transparency        = tree.factor_input("Transparency", min_value=0, max_value=1),
            ).geometry

        tree.geometry = circles.switch(-tree.bool_input("Show Curves")) + mesh
