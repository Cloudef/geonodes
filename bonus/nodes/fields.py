#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Jul  5 2024

@author: alain

-----------------------------------------------------
geonodes module
- Generates nodes with python
- Use numpy to manage vertices
-----------------------------------------------------

module : fields
---------------

Builds Geometry Nodes to generate fields. Fields can be visualized with Arrows.

Two types of trees are built:
    - Field computation : groups which compute the field vectors at given locations
    - Field visualization : modifiers which visualizes the previus field

Electromagnetic fields
----------------------

The computing groups computes E and B fields from parameters.
The modifiers use the groups to visualize one of the two fields

- G X Moving Charge Field / X Moving Charge Field : a single charge moving along X axis
- G Moving Charge Field / Moving Charge Field : a single charge moving in an arbitraty direction
- G Charges on Curve Field / Charges on Curve Fielf : several charges moving along a curve
- G XY Loop Radial Field : the radial field generated by a single solenoid loop
- G XY Loop Field : the field generated by a single solenoid loop
- G Solenoid Field / Solenoid Field : the field generated by a solenoid
- G Electric Field / Electric Field : electric field generated by charges

Utilities
---------
- Compute Lines of Field : compute field lines from a field computation. The field group uses position as socket input.
  the output socket E or B is used as input of the group 'G Field Lines'

"""
import numpy as np

import geonodes as gn
from geonodes.bonus.nodes import arrows as arrows_module

# =============================================================================================================================
# Visualize a field computed by a group
#
# The group must take the following input nodes
#
# - Position     : locations where to compute the field
# - kwargs       : kwargs passed in the function

def gen_field_visualization(tree, field_node):

    # ----- Visualisation parameters

    elec_field  = tree.bool_input(  "Electric field",       True, description="Show electric field rather than magnetic field")
    color       = tree.color_input( "Color",                (0., 0., 1., 1.), description="'Color' named attribute to pass to the shader")
    transp      = tree.factor_input("Transparency",         0., min_value=0., max_value=1, description="'Transparency' named attribute to pass to the shader")

    # ----- Arrows

    scale       = tree.float_input( "Scale",                1., min_value=0., description="Vectors multiplicator")
    curl_vect   = tree.bool_input(  "Curl Vectors",         False, description="Use curl shape for arrows")

    # ----- Lines of field

    field_lines = tree.bool_input(  "Lines of field",       False, description="Lines of field (True) or field of vectors (False)")
    iterations  = tree.int_input(   "Iterations",           20, min_value=1, description="Number of iterations to compute the lines of field")
    delta       = tree.float_input( "Delta",                .1, min_value=.001, description="Distance to move at each iteration")
    int_fac     = tree.factor_input("Intensity",            .9, min_value=0., max_value=1., description="Use intensity named attribute for radius")
    rand_dir    = tree.bool_input(  "Random Direction",     False, description="Build lines in random directions rather than in both directions")

    # ----- Geometry parameters

    resol       = tree.int_input(     "Resolution",         12, min_value=3, max_value=64, description="Lines / arrows section resolution")
    section     = tree.float_input(   "Section",            .02, min_value=0., max_value=1., description="Lines / arrows section")
    material    = tree.material_input("Material",           "Arrow", description="Arrows / lines material")

    # ----- Show / Hide

    show        = tree.bool_input(    "Show",               True, description="Show / hide flag")

    # ====================================================================================================
    # Utilities

    def get_field():
        return field_node.b.switch(elec_field, field_node.e)

    def build_lines(points, direction):
        return tree.group("Compute Lines of Field",
            geometry    = points,
            field       = get_field(),
            iterations  = iterations,
            delta       = delta,
            direction   = direction,
            ).geometry

    # ====================================================================================================
    # Main

    with tree.layout("Starting points"):
        comps_node = tree.geometry.separate_components()
        points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
        points = points.points_to_vertices()

    # ----------------------------------------------------------------------------------------------------
    # Arrows

    with tree.layout("Arrows"):

        points.store_named_vector("Vectors", get_field())

        arrows = tree.group("Arrows", points,
            scale         = scale,
            resolution    = resol,
            section       = section,
            sphere        = curl_vect,
            color         = color,
            transparency  = transp,
            shaft         = material,
            head          = material,
            ).geometry

    # ----------------------------------------------------------------------------------------------------
    # Lines of field

    with tree.layout("Lines of field"):
        curves  = build_lines(points, 1)
        curves += build_lines(points, -1)

        curves = curves.switch(rand_dir, build_lines(points, tree.integer(1).switch(tree.random_boolean(.5), -1)))

        lines = tree.group("To Lines of Field",
                geometry         = curves,
                resolution       = resol,
                radius           = section,
                intensity_factor = int_fac,
                transparency     = transp,
                color            = color,
                material         = material,
                ).geometry

    mesh = arrows.switch(field_lines, lines)

    # ----- Done

    return mesh.switch(-show)

# =============================================================================================================================
# Build function

def build_fields(clear_sockets=False):

    arrows_module.build_arrows()
    print("\nCreate fields modifiers...")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Frame change

    with gn.GeoNodes("G Frame Change", clear_sockets=clear_sockets, is_group=True) as tree:

        position  = tree.vector_input("Position")
        vector    = tree.vector_input("Vector")
        center    = tree.vector_input("Center")
        direction = tree.vector_input("Direction",  (1, 0, 0))
        back      = tree.bool_input(  "Reverse",     False)

        # ----- Rotation to have the direction along x axis

        with tree.layout("Rotation to have direction along x axis"):

            rotation = tree.AlignEulerToVector(vector=direction, axis='X').output_socket
            inverse  = rotation.clone.invert_rotation()

        # ----- Rotate vectors

        with tree.layout("Rotate vectors"):

            forward_vector  = vector.clone.rotate_vector(inverse)
            backward_vector = vector.clone.rotate_vector(rotation)

            transformed_vector = forward_vector.switch(back, backward_vector)

        # ----- Transformation locations

        with tree.layout("Transform locations"):

            forward_position  = (position - center).rotate_vector(rotation=inverse)
            backward_position = position.rotate_vector(rotation=rotation) + center

            transformed_position = forward_position.switch(back, backward_position)


        transformed_position.to_output("Position")
        transformed_vector.to_output(  "Vector")

    # =============================================================================================================================
    # Electromagnetic Field computations
    # The groups returns E and B sockets

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electric Field

    with gn.GeoNodes("G Electric Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position = tree.vector_input(  "Position")
        charges  = tree.geometry_input("Charges")
        max_len  = tree.float_input("Max Length", 1000, min_value=1)

        with tree.layout("Mesh or Points input"):
            comps = charges.separate_components()

            points = comps.point_cloud + comps.mesh.mesh_to_points()
            count = points.CLOUD.domain_size(component='CLOUD').point_count

        with tree.repeat(field=tree.vector((0, 0, 0)), index=0, iterations=count) as rep:

            charge_loc = points.POINT.sample_index_vector(value=tree.position, index=rep.index)
            charge_val = points.POINT.sample_index_vector(value=points.named_float('Charge'), index=rep.index)

            v = position - charge_loc
            l = v.length()
            l3 = tree.max(1/max_len, l**3)
            rep.field += charge_val*v/l3

            rep.index += 1

        rep.field.to_output("E")
        tree.vector((0, 0, 0)).to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a moving charge along x axis

    with gn.GeoNodes("G X Moving Charge Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        t           = tree.float_input(  "t")
        max_len     = tree.float_input(  "Max Length", 1000, min_value=1)

        x, y, z = position.x, position.y, position.z
        xb = x - beta*t
        vect = tree.vector((xb, y, z))
        rho = vect.length()

        with tree.layout("Gamma"):
            gamma = 1/tree.sqrt(1 - beta**2)

        gr3 = charge*gamma/rho**3

        E = gr3*vect
        B = (gr3*beta)*tree.vector((0, -z, y))

        E = E.normalize().scale(tree.min(E.length(), max_len))
        B = B.normalize().scale(tree.min(B.length(), max_len))

        E.to_output("E")
        B.to_output("B")
        vect.to_output("Charge location")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a charge moving in an arbitray direction

    with gn.GeoNodes("G Moving Charge Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge_loc  = tree.vector_input( "Charge location")
        charge      = tree.float_input(  "Charge",          1.)
        speed       = tree.vector_input( "Speed")

        with tree.layout("Ensure beta is not greater than 1"):
            length = speed.length()
            beta   = tree.min(length, .999)
            speed  = speed.scale(beta/length).switch(length.equal(0, .001), (0, 0, 0))

        with tree.layout("X along the speed"):

            rotation = tree.AlignEulerToVector(vector=speed, axis='X').output_socket
            keep = rotation.node.output_socket

            inverse  = rotation.invert_rotation()
            rotated_position = (position - charge_loc).rotate_vector(rotation=inverse)

            rotated_field = tree.group("G X Moving Charge Field",
                position        = rotated_position,
                charge          = charge,
                beta            = beta,
                t               = t,
                )

        with tree.layout("Rotate back"):
            field = rotated_field.e.rotate_vector(rotation=keep)
            field.to_output("E")

            field = rotated_field.b.rotate_vector(rotation=keep)
            field.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by charges along a curve

    with gn.GeoNodes("G Charges on Curve Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input(  "Position")

        source      = tree.geometry_input("Source Curve")
        count       = tree.int_input(     "Count",           1, min_value=1, max_value=1000)
        t           = tree.float_input(   "t")
        charge      = tree.float_input(   "Charge",           1.)
        beta        = tree.float_input(   "Beta",            .8, min_value=-.999, max_value=.999)

        # ----------------------------------------------------------------------------------------------------
        # Main

        dt = 1/count
        spheres = tree.points(count=count)

        with tree.repeat(spheres=spheres, field=tree.vector((0, 0, 0)), e=tree.vector((0, 0, 0)), b=tree.vector((0, 0, 0)), index=0, iterations=count) as rep:

            sample_node = source.sample_curve(mode='FACTOR', factor=tree.abs(rep.index*dt + t) % 1, curve_index=0)

            charge_loc   = sample_node.position
            charge_speed = sample_node.tangent.scale(beta)

            rep.spheres.POINT[rep.index].position = charge_loc

            field_node = tree.group("G Moving Charge Field",
                position        = position,
                charge          = charge/count,
                charge_location = charge_loc,
                speed           = charge_speed,
                )

            rep.e     += field_node.e
            rep.b     += field_node.b

            rep.index += 1

        rep.e.to_output("E")
        rep.b.to_output("B")
        rep.spheres.to_output("Charge Locations")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a loop in the plane XY at distance r and altitude z

    with gn.GeoNodes("G XY Loop Radial Field", clear_sockets=clear_sockets, is_group=True) as tree:

        r      = tree.float_input("r")
        z      = tree.float_input("z")
        charge = tree.float_input("Charge", 1.)
        beta   = tree.float_input("Beta",   .8, min_value=-.999, max_value=.999)
        R      = tree.float_input("Radius", 1., min_value=.1, max_value=10)

        # -----------------------------------------------------------------------------------------------------------------------------
        # Main

        count = 100

        with tree.layout("Cosine and Sine"):
            circle = tree.MeshCircle(vertices=count, radius=1).mesh

        with tree.layout("-2*gamma*charge"):
            gam_charge = (-2*charge/count)*(1 - beta**2)**(-1.5)

        # Integration loop

        with tree.repeat(ex=0., ez=0., bx=0., bz=0., index=0, iterations=count) as rep:

            cos_sin = circle.sample_index_vector(value=tree.position, index=rep.index)
            rep.index += 1

            cos_theta_, sin_theta_ = cos_sin.x, cos_sin.y

            rho_x = r - R*cos_theta_
            rho_y = R*sin_theta_
            gr3 = gam_charge*tree.max(.01, tree.vector((rho_x, rho_y, z)).length())**-3

            rep.ex += rho_x*gr3
            rep.ez += z*gr3

            rep.bx += z*cos_theta_*gr3
            rep.bz += (R - r*cos_theta_)*gr3

        with tree.layout("Fields"):
            tree.vector((rep.ex, 0, rep.ez)).to_output("E")
            tree.vector((rep.bx, 0, rep.bz)).to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a loop in the plane XY at distance r and altitude z

    with gn.GeoNodes("G XY Loop Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")
        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        radius      = tree.float_input(  "Radius", 1., min_value=.1, max_value=10)
        loops       = tree.int_input(    "Loops",  10, min_value=1)
        length      = tree.float_input(  "Length", 5., min_value=.1, max_value=10)

        # -----------------------------------------------------------------------------------------------------------------------------
        # Main

        with tree.layout("To cylindrical"):
            x, y, z = position.x, position.y, position.z
            r = (position*(1, 1, 0)).length()
            ag = tree.arctan2(y, x)

        #with tree.layout("Solenoid length"):
        #    l2 = length/2
        #    index = tree.integer(0).switch(z.less_than(-l2), 1).switch(z.greater_than(l2), 2)
        #    z_ = tree.IndexSwitch(0., z + l2, z - l2, index=index, data_type='FLOAT').output

        # ----- Loop on the solenoid loops :-)

        with tree.repeat(e=tree.vector(), b=tree.vector(), index=0, iterations=loops) as rep:

            with tree.layout("dz"):
                dz = length/loops

            with tree.layout("Loop z location"):
                loop_z = length*(-.5) + dz/2 + dz*rep.index

            with tree.layout("Z offset"):
                z_ = z - loop_z

            with tree.layout("Loop charge"):
                charge_ = charge/loops

            field_node = tree.group("G XY Loop Radial Field",
                r      = r,
                z      = z_,
                charge = charge_,
                beta   = beta,
                radius = radius,
                )

            rep.e += field_node.e
            rep.b += field_node.b
            rep.index += 1

        E = rep.e.rotate_vector(rotation=(0, 0, ag))
        B = rep.b.rotate_vector(rotation=(0, 0, ag))

        #E = field_node.e.rotate_vector(rotation=(0, 0, ag))
        #B = field_node.b.rotate_vector(rotation=(0, 0, ag))

        E.to_output("E")
        B.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoid

    with gn.GeoNodes("G Solenoid Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")
        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        radius      = tree.float_input(  "Radius",          1., min_value=.1, max_value=10)
        loops       = tree.int_input(    "Loops",           10, min_value=1)
        length      = tree.float_input(  "Length",          5., min_value=.1, max_value=10)

        # -----------------------------------------------------------------------------------------------------------------------------
        # Main

        with tree.layout("Computation is made vertically, solenoid is along x"):
            x, y, z = position.x, position.y, position.z
            pos = tree.vector((y, z, x))

        node = tree.group("G XY Loop Field",
            position = pos,
            charge   = charge,
            beta     = beta,
            radius   = radius,
            loops    = loops,
            length   = length,
            )

        E = tree.vector((node.e.z, node.e.x, node.e.y))
        B = tree.vector((node.b.z, node.b.x, node.b.y))

        E.to_output("E")
        B.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Field emitted by charges moving on a segment along X and centered on the origin

    with gn.GeoNodes("G Segment Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        length      = tree.float_input(  "Length",          1., min_value=0.01)

        # ----- Main

        x, y, z = position.x, position.y, position.z
        a2 = y**2 + z**2

        L = length/2

        with tree.layout("G(L) and F(L)"):

            lx1 = L - x
            GL1 = 1/tree.sqrt(a2 + lx1**2)
            FL1 = lx1/a2*GL1

        with tree.layout("G(-L) and F(-L)"):

            lx0 = -L - x
            GL0 = 1/tree.sqrt(a2 + lx0**2)
            FL0 = lx0/a2*GL0

        with tree.layout("Integrals"):
            FL = FL1 - FL0
            GL = GL1 - GL0

        with tree.layout("Gamma"):
            gamma = charge*(1 - beta**2)**1.5

        E = gamma*tree.vector((GL, y*FL, z*FL))
        B = gamma*beta*tree.vector((0, -z*FL, y*FL))

        E.to_output("E")
        B.to_output("B")

        tree.CurveLine(start=(-L, 0, 0), end=(L, 0, 0)).curve.to_output("Segment")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Field emitted by charges moving on a rectangular shape in the plane XY

    with gn.GeoNodes("G Rectangle Loop Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        size_y      = tree.float_input(  "Size Y",          1., min_value=0.01)
        size_z      = tree.float_input(  "Size Z",          1., min_value=0.01)

        with tree.layout("Share the charge on the sides"):
            total_size = (size_y + size_z)*2
            charge_y = charge*size_y/total_size
            charge_z = charge*size_z/total_size

        with tree.layout("Computation are made in plane XY"):
            position = position.rotate_vector(rotation=(0, np.pi/2, 0))

        node = tree.group("G Segment Field",
                    position = position - tree.vector((0, size_z*(-.5), 0)),
                    charge   = charge_y,
                    beta     = beta,
                    length   = size_y,
                    )

        E = node.e
        B = node.b

        node = tree.group("G Segment Field",
                    position = position - tree.vector((0, size_z/2, 0)),
                    charge   = -charge_y,
                    beta     = beta,
                    length   = size_y,
                    )

        E += node.e
        B += node.b

        rot_pos = position.rotate_vector(rotation=(0, 0, np.pi/2))
        rotation = tree.vector((0, 0, -np.pi/2))

        node = tree.group("G Segment Field",
                    position = rot_pos - tree.vector((0, size_y*(-.5), 0)),
                    charge   = charge_z,
                    beta     = beta,
                    length   = size_z,
                    )

        E += node.e.rotate_vector(rotation)
        B += node.b.rotate_vector(rotation)

        node = tree.group("G Segment Field",
                    position = rot_pos - tree.vector((0, size_y/2, 0)),
                    charge   = -charge_z,
                    beta     = beta,
                    length   = size_z,
                    )

        E += node.e.rotate_vector(rotation)
        B += node.b.rotate_vector(rotation)

        with tree.layout("Rotate the loop in the plane YZ"):

            E = E.rotate_vector(rotation=(0, -np.pi/2, 0))
            B = B.rotate_vector(rotation=(0, -np.pi/2, 0))

            curve = tree.Grid(size_x=size_y, size_y=size_z, vertices_x=2, vertices_y=2).mesh.mesh_to_curve()
            curve.transform_geometry(rotation=(0, -np.pi/2, 0))


        E.to_output("E")
        B.to_output("B")

        curve.to_output("Rectangle")

    # =============================================================================================================================
    # Compute Curl

    with gn.GeoNodes("Compute Curl", clear_sockets=clear_sockets) as tree:

        # ----- Parameters

        field       = tree.vector_input(  "Field", description="Field computation from 'position' Node")
        ds          = tree.float_input(   "ds", .1, min_value=0.001, description="Precision")
        normalize   = tree.bool_input(    "Normalize", True, description="Return the raw (False) or normalized (True)")
        scale       = tree.float_input(   "Scale", 1., description="Scale")

        # ---- Main

        with tree.layout("Computation points"):
            comps_node = tree.geometry.separate_components()
            points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
            points = points.points_to_vertices()

        ds2_ = -.5*ds

        with tree.layout("Along X"):
            points.transform_geometry(translation=(ds2_, 0, 0))
            points.POINT.store_named_vector("Before", field)
            points.transform_geometry(translation=(ds, 0, 0))
            points.POINT.store_named_vector("After", field)
            points.transform_geometry(translation=(ds2_, 0, 0))

            points.POINT.store_named_vector("dvx", points.POINT.named_vector("After") - points.POINT.named_vector("Before"))

        with tree.layout("Along Y"):
            points.transform_geometry(translation=(0, ds2_, 0))
            points.POINT.store_named_vector("Before", field)
            points.transform_geometry(translation=(0, ds, 0))
            points.POINT.store_named_vector("After", field)
            points.transform_geometry(translation=(0, ds2_, 0))

            points.POINT.store_named_vector("dvy", points.POINT.named_vector("After") - points.POINT.named_vector("Before"))

        with tree.layout("Along Z"):
            points.transform_geometry(translation=(0, 0, ds2_))
            points.POINT.store_named_vector("Before", field)
            points.transform_geometry(translation=(0, 0, ds))
            points.POINT.store_named_vector("After", field)
            points.transform_geometry(translation=(0, 0, ds2_))

            points.POINT.store_named_vector("dvz", points.POINT.named_vector("After") - points.POINT.named_vector("Before"))

        with tree.layout("Curl"):
            dvx, dvy, dvz = points.POINT.named_vector("dvx"), points.POINT.named_vector("dvy"), points.POINT.named_vector("dvz")
            curl = tree.vector((
                dvy.z - dvz.y,
                dvx.z - dvz.x,
                dvx.y - dvy.x,
            ))
            curl = curl.scale(scale)
            points.POINT.store_named_vector("Vectors", curl.switch(normalize, curl.scale(1/ds)))

        points.remove_named_attribute("Before")
        points.remove_named_attribute("After")
        points.remove_named_attribute("dvx")
        points.remove_named_attribute("dvy")
        points.remove_named_attribute("dvz")

        tree.geometry = points

    # =============================================================================================================================
    # Lorentz transformation

    with gn.GeoNodes("EM Lorentz", is_group=True) as tree:

        speed = tree.vector_input(      "Speed",        (.8, 0, 0))
        E     = tree.vector_input(      "E")
        B     = tree.vector_input(      "B")

        # ----- Make sure beta is ok

        with tree.layout("Ensure beta is not greater than 1"):
            length = speed.length()
            beta   = tree.min(length, .999)
            speed  = speed.scale(beta/length).switch(length.equal(0), (0, 0, 0))

        # ----- Rotate to have speed along x axis

        with tree.layout("Rotate fields to have speed long x axis"):

            rotation = tree.AlignEulerToVector(vector=speed, axis='X').output_socket
            #keep = rotation.node.output_socket

            inverse  = rotation.clone.invert_rotation()
            Erot = E.rotate_vector(rotation=inverse)
            Brot = B.rotate_vector(rotation=inverse)

        # ----- Lorentz transformation

        with tree.layout("Lorentz transformation"):

            gamma = tree.power(1 - beta**2)**(-.5)

            Erx, Ery, Erz = Erot.x, Erot.y, Erot.z
            Brx, Bry, Brz = Brot.x, Brot.y, Brot.z

            Erot_ = tree.vector((
                Erx,
                gamma*(Ery - beta*Brz),
                gamma*(Erz + beta*Bry)
            ))

            Brot_ = tree.vector((
                Brx,
                gamma*(Bry + beta*Erz),
                gamma*(Brz - beta*Ery)
            ))

        # ----- Rotate back

        with tree.layout("Rotate back"):
            E_ = Erot_.rotate_vector(rotation=rotation)
            B_ = Brot_.rotate_vector(rotation=rotation)

        # ----- Done

        E_.to_output("E")
        B_.to_output("B")


    # =============================================================================================================================
    # Compute the lines of field

    with gn.GeoNodes("Compute Lines of Field", clear_sockets=clear_sockets) as tree:

        # ----- Field

        field       = tree.vector_input(  "Field", description="Field computation from 'position' Node")

        # ----- Algorithm parameter

        iterations  = tree.int_input(     "Iterations", 20,    min_value=1, description="Number of iterations per line")
        delta       = tree.float_input(   "Delta",      .1,    min_value=.001, description="Distance to move at each iteration")
        direction   = tree.float_input(   "Direction",  1., description="Move forwards (+1) or backwards (-1)")
        origin      = tree.vector_input(  "Origin", description="Origin to compute the distance from")
        max_dist    = tree.float_input(   "Max Distance",  100., description="Ignore points beyond the max distance")

        # ----------------------------------------------------------------------------------------------------
        # Main

        with tree.layout("Starting points"):
            comps_node = tree.geometry.separate_components()
            points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
            points = points.points_to_vertices()

            points.store_named_float("DELTA", delta*direction)
            points.POINT.delete_geometry(origin.distance(tree.position).greater_than(max_dist))

        with tree.repeat(points=points, top=True, iterations=iterations) as rep:

            with tree.layout("Vector computation"):

                with tree.layout("Displacement from current points"):
                    v0 = field
                    l0 = v0.length()

                    rep.points.POINT[rep.top].store_named_float("Intensity", l0)

                    #rep.top &= l0 < 10
                    rep.top &= l0 > 0.001

                    v0 = v0.normalize().scale(rep.points.named_float("DELTA"))

                with tree.layout("Extrude from this first displacement"):

                    mesh = rep.points.POINT[rep.top].extrude_mesh(offset=v0)
                    top  = mesh.node.top

                with tree.layout("Displacement from extruded point"):

                    v1 = field
                    v1 = v1.normalize().scale(rep.points.named_float("DELTA"))
                    #v1 = tree.vector((0, 0, 0)).switch(average, (v1 - v0).scale(.5))
                    v1 = (v1 - v0).scale(.5)

                    rep.points.POINT[top].offset = v1

            rep.top    = top
            rep.points = mesh

        mesh = rep.points
        mesh.remove_named_attribute("DELTA")

        tree.geometry = mesh.mesh_to_curve()

    # =============================================================================================================================
    # Visualize spheres on points

    def gen_spheres_on_charges(tree, charges_loc):

        sph_radius   = tree.float_input(   "Spheres Radius",   .1, min_value=0., description="Spheres radius (0 if charges must not be visualized)")
        sph_color    = tree.color_input(   "Spheres Color", description="Spheres 'Color' named attribute to pass to the Shader")
        sph_mat      = tree.material_input("Spheres Material", description="Spheres material")

        with tree.layout("Spheres on charges"):
            charges_loc.store_named_vector("Color", sph_color)
            spheres = charges_loc.instance_on_points(instance=tree.UVSphere(radius=sph_radius).mesh)
            spheres = spheres.realize_instances()
            spheres.FACE.shade_smooth = True
            spheres.FACE.material = sph_mat

        return spheres.switch(sph_radius.equal(0))

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("Electric Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charges_obj = tree.object_input("Charges location", 1., description="Geometry proving the locations of the charges")
        charge_min  = tree.float_input( "Min Charge", -1., description="Minimum value for electric charge")
        charge_max  = tree.float_input( "Max Charge",  1., description="Maximum value for electric charge")
        seed = tree.int_input(          "Seed",        0,  description="Random seed")

        # ----- Main

        charges = charges_obj.object_info().geometry
        charges.POINT.store_named_float("Charge", tree.random_float(min=charge_min, max=charge_max, seed=seed))

        field_node = tree.group("G Electric Field",
            position = tree.position,
            charges  = charges,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, charges)

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("X Moving Charge Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charge      = tree.float_input(  "Charge", 1., description="Value of the charge")
        beta        = tree.float_input(  "Beta",   0, min_value=-.999, max_value=.999, description="Beta relativist speed")
        t           = tree.float_input(  "t", description="Time")
        max_len     = tree.float_input(  "Max Lengh", 1., description="Max Vectors Length")

        # ----- Main

        field_node = tree.group("G X Moving Charge Field",
            position   = tree.position,
            charge     = charge,
            beta       = beta,
            t          = t,
            max_length = max_len,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, tree.Points(count=1, position=(beta*t, 0, 0)).points)
        field_node.charge_location.to_output("Charge location")

    # ----------------------------------------------------------------------------------------------------
    # A charge moving in an arbitrary direction

    with gn.GeoNodes("Moving Charge Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters

        charge_loc  = tree.vector_input( "Charge location", description="Charge location")
        charge      = tree.float_input(  "Charge",  1., description="Value of the charge")
        speed       = tree.vector_input( "Speed", (.8, 0, 0), description="Charge speed (length must be less than 1)")

        # ----- Main

        field_node = tree.group("G Moving Charge Field",
            position        = tree.position,
            charge_location = charge_loc,
            speed           = speed,
            )

        tree.geometry = gen_field_visualization(tree, field_node) + gen_spheres_on_charges(tree, tree.Points(count=1, position=charge_loc).points)

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by several charges

    with gn.GeoNodes("Charges on Curve Field", clear_sockets=clear_sockets) as tree:

        # ----- Field parameters0

        source_curve = tree.object_input(  "Source Curve", description="Curve on which charges are moving")
        count        = tree.int_input(     "Charges count",    10, min_value=1, max_value=1000, description="Number of charges")
        t            = tree.float_input(   "t",                0., description="Time for charges animation")
        charge       = tree.float_input(   "Charge",           1., description="Total charge")
        beta         = tree.float_input(   "Beta",             .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        sph_radius   = tree.float_input(   "Spheres Radius",   .1, min_value=0., description="Charges sphere radius (0 if charges must not be visualized)")
        sph_mat      = tree.material_input("Spheres Material", description="Charges material")

        # ----- Main

        curve = source_curve.object_info().geometry

        field_node = tree.group("G Charges on Curve Field",
            position        = tree.position,
            source_curve    = curve,
            count           = count,
            t               = t,
            charge          = charge,
            beta            = beta,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with tree.layout("Spheres"):

            sph_locs = field_node.charge_locations
            spheres = sph_locs.instance_on_points(instance=tree.UVSphere(radius=sph_radius).mesh)
            spheres.FACE.shade_smooth = True
            spheres.FACE.material = sph_mat

        tree.geometry = field_visu + spheres.switch(sph_radius.equal(0))

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoide

    with gn.GeoNodes("Solenoid Field", clear_sockets=clear_sockets) as tree:

        charge      = tree.float_input(  "Charge",      1., description="Total charge")
        beta        = tree.float_input(  "Beta",        .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        radius      = tree.float_input(  "Radius",      1., min_value=.1, max_value=10, description="Solenoid radius")
        length      = tree.float_input(  "Length",      5., min_value=.1, max_value=10, description="Solenoid length")

        # ---- Solenoid

        wire_radius  = tree.float_input(   "Wire radius", .1, min_value=.001, description="Radius of the wire (0 for no visualization)")
        wire_mat     = tree.material_input("Wire Material", description="Wire material")

        # ----- Main

        field_node = tree.group("G Solenoid Field",
            position        = tree.position,
            charge          = charge,
            beta            = beta,
            radius          = radius,
            length          = length,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with tree.layout("Solenoid"):

            loops = tree.min(30, tree.max(1, length/2/wire_radius))

            wire_curve = tree.Spiral(
                #resolution      = 32,
                rotations       = loops,
                start_radius    = radius,
                end_radius      = radius,
                height          = length,
                ).curve

            wire_curve.transform_geometry(translation=(-length/2, 0, 0), rotation=(0, np.pi/2, 0))

            wire = wire_curve.curve_to_mesh(profile_curve=tree.CurveCircle(radius=wire_radius, resolution=12).curve)

            wire.FACE.shade_smooth = True
            wire.FACE.material     = wire_mat

        tree.geometry = field_visu + wire.switch(wire_radius.equal(0))

    # =============================================================================================================================
    # Magnet

    # -----------------------------------------------------------------------------------------------------------------------------
    # A single magnetic loop from a magnet
    #
    # Loop is an ellipsis tangent to x axis defined by its length (along x)
    # and width scale (along y)

    with gn.GeoNodes("Magnet Single Loop", clear_sockets=clear_sockets) as tree:

        length      = tree.float_input("Length", 1., min_value=0.)
        width_scale = tree.float_input("Width Scale",  1., min_value=0.01)
        angle       = tree.angle_input("Angle",  0.)
        count       = tree.int_input(  "Resolution", 32, min_value=3)

        # ----- Main

        width = length * width_scale

        circle = tree.MeshCircle(vertices=count, radius=1).mesh
        x, y = tree.position.x, tree.position.y
        circle.POINT.store_named_float("Intensity", (1.01 - y)*length)

        x = tree.position.x * length
        y = tree.position.y * width + width
        z = tree.position.z

        circle.POINT.position = tree.vector((x, y, z))
        circle.transform_geometry(rotation=(angle, 0, 0))

        tree.geometry = circle.mesh_to_curve()

    # -----------------------------------------------------------------------------------------------------------------------------
    # Magnet loops
    #
    # Compute the magnetic field loops from the points in the input geometry
    #
    # Given x, y, what is r such as:
    # x^ + (y - r)^2 = r^2
    # r = (x^2 + y^2)/2y

    with gn.GeoNodes("Magnet Loops", clear_sockets=clear_sockets) as tree:

        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01)
        location     = tree.vector_input(  "Location")
        rotation     = tree.rotation_input("Rotation")

        # ----- Input points

        with tree.layout("Input points"):
            comps = tree.geometry.separate_components()
            points = comps.point_cloud + comps.mesh.mesh_to_points()
            n = points.CLOUD.domain_size().point_count

        # ----- Computation is made for a magnet centered along the x axis

        with tree.layout("Center Magnet and align along x"):
            points.POINT.position = (tree.position - location).rotate_vector(rotation.clone.invert_rotation())

        # ----- Loop on the input points

        with tree.repeat(geometry=None, index=0, iterations=n) as rep:

            p = points.sample_index_vector(index=rep.index, value=tree.position)
            rep.index += 1

            x, y, z = p.x, p.y, p.z

            # ----- Plane passing through x axis

            angle = tree.arctan2(z, y)
            rot_y = tree.sqrt(y**2 + z**2)

            # ----- Width scale

            y_ = rot_y/width_scale

            r = (x**2 + y_**2)/2/y_

            # ----- Add a loop

            rep.geometry += tree.group("Magnet Single Loop",
                length      = r,
                width_scale = width_scale,
                angle       = angle,
                resolution  = 20 + r*20,
                ).geometry

        with tree.layout("Back to initial frame"):
            curves = rep.geometry
            curves.POINT.position = location + tree.position.rotate_vector(rotation)

        # ----- Done

        tree.geometry = curves

    # ----------------------------------------------------------------------------------------------------
    # Magnet field

    with gn.GeoNodes("G Magnet Field", clear_sockets=clear_sockets, is_group=True) as tree:

        position     = tree.vector_input(  "Position")
        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01)
        location     = tree.vector_input(  "Location")
        rotation     = tree.rotation_input("Rotation")
        speed        = tree.vector_input(  "Speed")

        # ----- Computation is made for a magnet centered along the x axis

        with tree.layout("Center Magnet and align along x"):
            position = (position - location).rotate_vector(rotation.clone.invert_rotation())

            x, y, z = position.x, position.y, position.z

        # ----- Plane passing through x axis

        with tree.layout("Plane containing point and x axis"):
            angle = tree.arctan2(z, y)
            rot_y = tree.sqrt(y**2 + z**2)

        # ----- Width scale

        y_ = rot_y/width_scale

        # ----- Normalized radius

        r = (x**2 + y_**2)/2/y_

        # ----- Normalized B

        B = tree.vector(((r - y_)/width_scale, x, 0)).normalize()

        # ----- Rotation

        B = B.rotate_vector(rotation=(angle, 0, 0))

        # ----- Back to the initial frame

        B = B.rotate_vector(rotation)

        with tree.layout("Take speed into account"):

            transf_node = tree.group("EM Lorentz", speed=speed, b=B)
            E = transf_node.e
            B = transf_node.b

        # ----- Done

        E.to_output("E")
        B.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Magnet Shape

    with gn.GeoNodes("Magnet Shape", clear_sockets=clear_sockets) as tree:

        location     = tree.vector_input(   "Location")
        rotation     = tree.rotation_input( "Rotation")

        # ----- Magnet shape

        round_profile = tree.bool_input(    "Round Profile", False)
        magnet_length = tree.float_input(   "Length", 1.)
        profile_size  = tree.float_input(   "Profile Size",  .3)
        profile_scale = tree.float_input(   "Profile Scale", .8)
        material      = tree.material_input("Material")
        show          = tree.bool_input(    "Show",           True)

        # ----- Magnet shape

        rect = tree.Grid(size_x=profile_size, size_y=profile_size*profile_scale, vertices_x=2, vertices_y=2).mesh.mesh_to_curve()
        ell  = tree.CurveCircle(radius=profile_size/2).curve.transform_geometry(scale=(1, profile_scale, 1))

        prof = rect.switch(round_profile, ell)
        prof.POINT.store_named_float("uvy", tree.spline_parameter.factor)

        base = tree.CurveLine(start=(magnet_length*(-.5), 0, 0), end=(magnet_length*.5, 0, 0)).curve
        base.POINT.store_named_float("uvx", tree.spline_parameter.factor)

        shape = base.curve_to_mesh(profile_curve=prof, fill_caps=True)
        shape.CORNER.store_named_vector("UVMap", tree.vector((shape.named_float("uvx"), shape.named_float("uvy"), 0)))
        shape.FACE.shade_smooth = False
        shape.FACE.material     = material

        shape = shape.transform_geometry(translation=location, rotation=rotation)

        tree.geometry = shape.switch(-show)

    # =============================================================================================================================
    # A full Magnet

    with gn.GeoNodes("Magnet", clear_sockets=clear_sockets) as tree:

        #raise tree.Break()

        # ----- Magnet specs

        width_scale  = tree.float_input(   "Width Scale",  1., min_value=0.01, description="Magnet field scale")
        location     = tree.vector_input(  "Location", description="Magnet location")
        rotation     = tree.rotation_input("Rotation", description="Magnet rotation")
        speed        = tree.vector_input(  "Speed",    description="Magnet speed")

        # ----- Magnet shape

        show_magnet   = tree.bool_input(    "Show Magnet")
        round_profile = tree.bool_input(    "Round Profile", False)
        magnet_length = tree.float_input(   "Length", 1.)
        profile_size  = tree.float_input(   "Profile Size",  .3)
        profile_scale = tree.float_input(   "Profile Scale", .8)
        magnet_mat    = tree.material_input("Magnet Material")

        # ----- Magnetic loops

        show_loops   = tree.bool_input(     "Show Magnetic Loops", True)
        loop_int_fac = tree.factor_input(   "Mag Lines Intensity", 1., min_value=0., max_value=1.)
        loop_section = tree.float_input(    "Mag Lines Section", .02, min_value=0., max_value=1.)
        min_loop_sec = tree.float_input(    "Min Mag Lines Section", 0, min_value=0., max_value=1.)
        loop_color   = tree.color_input(    "Mag Lines Color", (0, 1, 0, 1))
        loop_transp  = tree.factor_input(   "Mag Lines Transparency", 0., min_value=0., max_value=1.)
        loop_mat     = tree.material_input( "Mag Lines Material", "Arrow")

        loop_arrows  = tree.bool_input(     "Show Loops Arrows",    True)
        ar_scale     = tree.float_input(    "Scale",                1., min_value=0.)
        ar_dist      = tree.float_input(    "Distance",             .5, min_value=.1, )
        ar_section   = tree.float_input(    "Section",              .02, min_value=0., max_value=1.)
        ar_color     = tree.color_input(    "Color",                (0, 1, 0, 1))
        ar_transp    = tree.factor_input(   "Transparency",         0., min_value=0., max_value=1.)
        ar_mat       = tree.material_input( "Material",             "Arrow")

        # ----- Magnetic Arrows

        show_arrows  = tree.bool_input(     "Show Arrows",    True)

        # ----- Electric Field

        eshow_field   = tree.bool_input(     "Show Electric Field", False)
        e_max_dist    = tree.float_input(    "Max Distance to Magnet")
        eloop_int_fac = tree.factor_input(   "Elec Lines Intensity", 1., min_value=0., max_value=1.)
        eloop_section = tree.float_input(    "Elec Lines Section", .02, min_value=0., max_value=1.)
        min_eloop_sec = tree.float_input(    "Min Elec Lines Section", 0, min_value=0., max_value=1.)
        eloop_color   = tree.color_input(    "Elec Lines Color", (1, 0, 1, 1))
        eloop_transp  = tree.factor_input(   "ELec Lines Transparency", 0., min_value=0., max_value=1.)
        eloop_mat     = tree.material_input( "Elec Lines Material", "Arrow")

        eloop_arrows  = tree.bool_input(     "Show Elec Line Arrows",    False)

        ef_iterations = tree.int_input(      "Iterations", 20, min_value=2)
        ef_delta      = tree.float_input(    "Delta",      .1, min_value=0.001)

        ear_scale     = tree.float_input(    "Elec Scale",                1., min_value=0.)
        ear_dist      = tree.float_input(    "Elec Distance",             .5, min_value=.1, )
        ear_section   = tree.float_input(    "Elec Section",              .02, min_value=0., max_value=1.)
        ear_color     = tree.color_input(    "Elec Color",                (1, 0, 1, 1))
        ear_transp    = tree.factor_input(   "Elec Transparency",         0., min_value=0., max_value=1.)
        ear_mat       = tree.material_input( "Elec Material",             "Arrow")

        eshow_arrows  = tree.bool_input(     "Show Elec Arrows",    False)

        # ----- Main

        field_node = tree.group("G Magnet Field",
            position     = tree.position,
            width_scale  = width_scale,
            location     = location,
            rotation     = rotation,
            speed        = speed,
            )

        # ----- Magnet shape

        geo = tree.group("Magnet Shape",
                    location      = location,
                    rotation      = rotation,
                    round_profile = round_profile,
                    length        = magnet_length,
                    profile_size  = profile_size,
                    profile_scale = profile_scale,
                    material      = magnet_mat,
                    show          = show_magnet,
                    )

        # ----- Magnetic Field loops

        with tree.layout("Magnet loops"):

            loops_node = tree.group("Magnet Loops",
                geometry     = tree.geometry,
                width_scale  = width_scale,
                location     = location,
                rotation     = rotation,
            )

            lines_mesh = tree.group("Field Curve to Mesh",
                geometry           = loops_node.geometry,
                show_lines         = show_loops,
                intensity          = loop_int_fac,
                lines_section      = loop_section,
                min_lines_section  = min_loop_sec,
                lines_color        = loop_color,
                lines_transparency = loop_transp,
                lines_material     = loop_mat,

                show_arrows        = loop_arrows,
                scale              = ar_scale,
                distance           = ar_dist,
                section            = ar_section,
                color              = ar_color,
                transparency       = ar_transp,
                material           = ar_mat,
            ).geometry

            geo += lines_mesh

        # ----- Arrows

        with tree.layout("Arrows"):

            points = tree.geometry
            points.POINT.store_named_vector("Vectors", field_node.b)

            arrows = tree.group("Arrows",
                geometry     = points,
                scale        = ar_scale,
                section      = ar_section,
                color        = ar_color,
                transparency = ar_transp,
                shaft        = ar_mat,
                head         = ar_mat,
                show         = show_arrows,
                ).geometry

            geo += arrows

        # ----- Electric field

        with tree.layout("Electric Field"):

            elec_field_node = tree.group("Compute Lines of Field",
                geometry     = tree.geometry,
                field        = field_node.e,
                iterations   = ef_iterations.switch(tree.is_viewport, ef_iterations/10),
                delta        = ef_delta.switch(tree.is_viewport, ef_delta*10),
                direction    = tree.float(-1).switch(tree.random_boolean(probability=.5), 1),
                origin       = location,
                max_distance = e_max_dist,
            )

            lines_mesh = tree.group("Field Curve to Mesh",
                geometry           = elec_field_node.geometry,
                show_lines         = eshow_field,
                intensity          = eloop_int_fac,
                lines_section      = eloop_section,
                min_lines_section  = min_eloop_sec,
                lines_color        = eloop_color,
                lines_transparency = eloop_transp,
                lines_material     = eloop_mat,

                show_arrows        = eloop_arrows,
                scale              = ear_scale,
                distance           = ear_dist,
                section            = ear_section,
                color              = ear_color,
                transparency       = ear_transp,
                material           = ear_mat,
            ).geometry

            geo += lines_mesh

        # ----- Arrows

        with tree.layout("Electric Arrows"):

            points = tree.geometry
            points.POINT.store_named_vector("Vectors", field_node.e)

            arrows = tree.group("Arrows",
                geometry     = points,
                scale        = ear_scale,
                section      = ear_section,
                color        = ear_color,
                transparency = ear_transp,
                shaft        = ear_mat,
                head         = ear_mat,
                show         = eshow_arrows,
                ).geometry

            geo += arrows

        # ----- Done

        tree.geometry = geo

    # =============================================================================================================================
    # Quick Solenoid

    # -----------------------------------------------------------------------------------------------------------------------------
    # A single loop

    with gn.GeoNodes("Solenoid Single Magnetic Loop") as tree:

        position = tree.vector_input("Position")

        radius = tree.float_input("Radius", 1., min_value=.1)
        length = tree.float_input("Length", 5., min_value=.1)

        length_factor = tree.float_input("Length factor", 1.2, min_value=0)
        radial_factor = tree.float_input("Radial factor", 1.2, min_value=0)

        with tree.layout("Cylindrical coordinates"):
            x, y, z = position.x, position.y, position.z
            rho   = tree.vector((0, y, z)).length()
            theta = tree.arctan2(z, y)

        with tree.layout("Circle Radius to match length along X"):
            radius_x = rho.map_range(from_min=0, from_max=radius, to_min=(radius + length)*length_factor, to_max=0)

        with tree.layout("Base Circle"):
            circle=tree.curve_circle(radius=1, resolution=12 + radius_x*20)

        with tree.layout("Intensity"):
            cy = tree.position.y
            circle.POINT.store_named_float("Intensity", 1.01 - cy)


        with tree.layout("Deform along Y"):
            scale_y = rho.map_range(from_min=0, from_max=radius, to_min=radial_factor, to_max=0)
            radius_y = radius_x*scale_y
            circle = circle.transform_geometry(translation=(0, rho + radius_y, 0), scale=(radius_x, radius_x*scale_y, 1))

        circle = circle.transform_geometry(rotation=(theta, 0, 0))

        tree.geometry = circle

    # -----------------------------------------------------------------------------------------------------------------------------
    # A full magnetic field from a Solenoid

    with gn.GeoNodes("Solenoid Magnetic Field") as tree:

        density = tree.float_input(   "Density", 10, min_value= 0.)
        seed    = tree.integer_input( "Seed",    0)
        radius  = tree.float_input(   "Radius",  1., min_value=.1)
        length  = tree.float_input(   "Length",  5., min_value=.1)

        length_factor = tree.float_input("Length factor", 1.2, min_value=0)
        radial_factor = tree.float_input("Radial factor", 1.2, min_value=0)


        with tree.layout("Random source point"):
            disk = tree.MeshCircle(radius=radius, fill_type='NGON').mesh
            disk.transform_geometry(rotation=(0, gn.half_pi, 0))

            points = disk.distribute_points_on_faces(density_max=density*10, density_factor=density, seed=seed, distribute_method='POISSON', distance_min=radius/10).points
            count = points.CLOUD.domain_size().point_count


        with tree.repeat(geometry=None, index = 0, iterations=count) as rep:

            with tree.layout("Current point"):
                position = points.sample_index_vector(value=tree.position, index=rep.index)

            circle = tree.group("Solenoid Single Magnetic Loop",
                position = position,
                radius = radius,
                length = length,
                length_factor = length_factor,
                radial_factor = radial_factor,
                ).geometry

            rep.geometry += circle
            rep.index += 1

        circles = rep.geometry

        mesh = tree.group("Field Curve to Mesh",
            geometry            = circles,
            show_lines          = tree.bool_input("Show circles"),
            lines_section       = 0.02,
            lines_color         = tree.color_input("Circle Color"),
            lines_transparency  = tree.factor_input("Circles_transparency", min_value=0, max_value=1),
            show_arrows         = tree.bool_input("Show Arrows"),
            distance            = tree.float_input("Distance", .1, min_value=0.0001),
            scale               = tree.float_input("Scale", 1.),
            color               = tree.color_input("Color"),
            transparency        = tree.factor_input("Transparency", min_value=0, max_value=1),
            ).geometry

        tree.geometry = circles.switch(-tree.bool_input("Show Curves")) + mesh
