#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Jul  5 2024

@author: alain

-----------------------------------------------------
geonodes module
- Generates nodes with python
- Use numpy to manage vertices
-----------------------------------------------------

module : fields
---------------

Builds Geometry Nodes to generate fields. Fields can be visualized with Arrows.

Two types of trees are built:
    - Field computation : groups which compute the field vectors at given locations
    - Field visualization : modifiers which visualizes the previus field

Electromagnetic fields
----------------------

The computing groups computes E and B fields from parameters.
The modifiers use the groups to visualize one of the two fields

- G X Moving Charge Field / X Moving Charge Field : a single charge moving along X axis
- G Moving Charge Field / Moving Charge Field : a single charge moving in an arbitraty direction
- G Charges on Curve Field / Charges on Curve Fielf : several charges moving along a curve
- G XY Loop Radial Field : the radial field generated by a single solenoid loop
- G XY Loop Field : the field generated by a single solenoid loop
- G Solenoid Field / Solenoid Field : the field generated by a solenoid
- G Electric Field / Electric Field : electric field generated by charges

Utilities
---------
- Compute Lines of Field : compute field lines from a field computation. The field group uses position as socket input.
  the output socket E or B is used as input of the group 'G Field Lines'

"""
import numpy as np

import geonodes as gn
from geonodes.bonus.nodes import arrows

def build_fields():

    arrows.build_arrows()
    print("\nCreate fields modifiers...")

    # =============================================================================================================================
    # Electromagnetic Field computations
    # The groups returns E and B sockets

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electric Field

    with gn.GeoNodes("G Electric Field", is_group=True) as tree:

        position = tree.vector_input(  "Position")
        charges  = tree.geometry_input("Charges")

        with tree.layout("Mesh or Points input"):
            comps = charges.separate_components()

            points = comps.point_cloud + comps.mesh.mesh_to_points()
            count = points.CLOUD.domain_size(component='CLOUD').point_count

        with tree.repeat(field=tree.vector((0, 0, 0)), index=0, iterations=count) as rep:

            charge_loc = points.POINT.sample_index_vector(value=tree.position, index=rep.index)
            charge_val = points.POINT.sample_index_vector(value=points.named_float('Charge'), index=rep.index)

            v = position - charge_loc
            l = v.length()
            l3 = tree.max(.001, l**3)
            rep.field += charge_val*v/l3

            rep.index += 1

        rep.field.to_output("E")
        tree.vector((0, 0, 0)).to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a moving charge along x axis

    with gn.GeoNodes("G X Moving Charge Field", is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        t           = tree.float_input(  "t")

        x, y, z = position.x, position.y, position.z
        xb = x - beta*t
        vect = tree.vector((xb, y, z))
        rho = vect.length()

        with tree.layout("Gamma"):
            gamma = 1/tree.sqrt(1 - beta**2)

        gr3 = charge*gamma/rho**3

        E = gr3*vect
        B = (gr3*beta)*tree.vector((0, -z, y))

        E.to_output("E")
        B.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a charge moving in an arbitray direction

    with gn.GeoNodes("G Moving Charge Field", is_group=True) as tree:

        position    = tree.vector_input( "Position")

        charge_loc  = tree.vector_input( "Charge location")
        charge      = tree.float_input(  "Charge",          1.)
        speed       = tree.vector_input( "Speed")

        with tree.layout("Ensure beta is not greater than 1"):
            length = speed.length()
            beta   = tree.min(length, .999)
            speed  = speed.scale(beta/length).switch(length.equal(0, .001), (0, 0, 0))

        with tree.layout("X along the speed"):

            rotation = tree.AlignEulerToVector(vector=speed, axis='X').output_socket
            keep = rotation.node.output_socket

            inverse  = rotation.invert_rotation()
            rotated_position = (position - charge_loc).rotate_vector(rotation=inverse)

            rotated_field = tree.group("G X Moving Charge Field",
                position        = rotated_position,
                charge          = charge,
                beta            = beta,
                t               = t,
                )

        with tree.layout("Rotate back"):
            field = rotated_field.e.rotate_vector(rotation=keep)
            field.to_output("E")

            field = rotated_field.b.rotate_vector(rotation=keep)
            field.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoid

    with gn.GeoNodes("G Charges on Curve Field", is_group=True) as tree:

        position    = tree.vector_input(  "Position")

        source      = tree.geometry_input("Source Curve")
        count       = tree.int_input(     "Count",           1, min_value=1, max_value=1000)
        t           = tree.float_input(   "t")
        charge      = tree.float_input(   "Charge",           1.)
        beta        = tree.float_input(   "Beta",            .8, min_value=-.999, max_value=.999)

        # ----------------------------------------------------------------------------------------------------
        # Main

        dt = 1/count
        spheres = tree.points(count=count)

        with tree.repeat(spheres=spheres, field=tree.vector((0, 0, 0)), e=tree.vector((0, 0, 0)), b=tree.vector((0, 0, 0)), index=0, iterations=count) as rep:

            sample_node = source.sample_curve(mode='FACTOR', factor=tree.abs(rep.index*dt + t) % 1, curve_index=0)

            charge_loc   = sample_node.position
            charge_speed = sample_node.tangent.scale(beta)

            rep.spheres.POINT[rep.index].position = charge_loc

            field_node = tree.group("G Moving Charge Field",
                position        = position,
                charge          = charge/count,
                charge_location = charge_loc,
                speed           = charge_speed,
                )

            rep.e     += field_node.e
            rep.b     += field_node.b

            rep.index += 1

        rep.e.to_output("E")
        rep.b.to_output("B")
        rep.spheres.to_output("Charge Locations")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a loop in the plane XY at distance r and altitude z

    with gn.GeoNodes("G XY Loop Radial Field", is_group=True) as tree:

        r           = tree.float_input(  "r")
        z           = tree.float_input(  "z")
        charge      = tree.float_input(  "Charge", 1.)
        beta        = tree.float_input(  "Beta",   .8, min_value=-.999, max_value=.999)
        R           = tree.float_input(  "Radius", 1., min_value=.1, max_value=10)

        # -----------------------------------------------------------------------------------------------------------------------------
        # Main

        count = 100

        with tree.layout("Cosine and Sine"):
            circle = tree.MeshCircle(vertices=count, radius=1).mesh
            cos_theta, sin_theta = tree.position.x, tree.position.y
            Rcos = R*cos_theta

        with tree.layout("Rho ** 3"):
            rho2 = (r - Rcos)**2 + (R*sin_theta)**2 + z**2
            rho3 = tree.max(rho2**1.5, .001)

        with tree.layout("-2*gamma*charge/rho3"):
            gr3 = -2/tree.sqrt(1 - beta**2)*charge/count/rho3

        # Integration

        with tree.repeat(ex=0., ez=0., bx=0., bz=0., index=0, iterations=count) as rep:

            cos_theta_ = circle.sample_index(value=cos_theta, index=rep.index)
            Rcos_      = circle.sample_index(value=Rcos,      index=rep.index)
            gr3_       = circle.sample_index(value=gr3,       index=rep.index)
            rep.index += 1

            rep.ex += (r - Rcos_)*gr3_
            rep.ez += z*gr3_

            rep.bx += z*cos_theta_*gr3_
            rep.bz += (R - r*cos_theta_)*gr3_

        with tree.layout("Fields"):
            tree.vector((rep.ex, 0, rep.ez)).to_output("E")
            tree.vector((rep.bx, 0, rep.bz)).to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a loop in the plane XY at distance r and altitude z

    with gn.GeoNodes("G XY Loop Field", is_group=True) as tree:

        position    = tree.vector_input( "Position")
        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        radius      = tree.float_input(  "Radius", 1., min_value=.1, max_value=10)
        length      = tree.float_input(  "Length", 5., min_value=.1, max_value=10)

        # -----------------------------------------------------------------------------------------------------------------------------
        # Main

        with tree.layout("To spherical"):

            x, y, z = position.x, position.y, position.z
            r = (position*(1, 1, 0)).length()
            ag = tree.arctan2(y, x)

        with tree.layout("Solenoid length"):
            l2 = length/2
            index = tree.integer(0).switch(z.less_than(-l2), 1).switch(z.greater_than(l2), 2)
            z_ = tree.IndexSwitch(0., z + l2, z - l2, index=index, data_type='FLOAT').output


        field_node = tree.group("G XY Loop Radial Field",
            r      = r,
            z      = z_,
            charge = charge,
            beta   = beta,
            radius = radius,
            )

        E = field_node.e.rotate_vector(rotation=(0, 0, ag))
        B = field_node.b.rotate_vector(rotation=(0, 0, ag))

        E.to_output("E")
        B.to_output("B")

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated the loop of a solenoid

    with gn.GeoNodes("G Solenoid Field", is_group=True) as tree:

        position    = tree.vector_input( "Position")
        charge      = tree.float_input(  "Charge",          1.)
        beta        = tree.float_input(  "Beta",            .8, min_value=-.999, max_value=.999)
        radius      = tree.float_input(  "Radius",          1., min_value=.1, max_value=10)
        length      = tree.float_input(  "Length",          5., min_value=.1, max_value=10)

        # -----------------------------------------------------------------------------------------------------------------------------
        # Main

        with tree.layout("Computation is made vertically, solenoid is along x"):
            x, y, z = position.x, position.y, position.z
            pos = tree.vector((y, z, x))

        node = tree.group("G XY Loop Field",
            position = pos,
            charge   = charge,
            beta     = beta,
            radius   = radius,
            length   = length,
            )

        E = tree.vector((node.e.z, node.e.x, node.e.y))
        B = tree.vector((node.b.z, node.b.x, node.b.y))

        E.to_output("E")
        B.to_output("B")

    # =============================================================================================================================
    # Compute the lines of field

    with gn.GeoNodes("Compute Lines of Field") as tree:

        # ----- Field

        field       = tree.vector_input(  "Field", description="Field computation from 'position' Node")

        # ----- Algorithm parameter

        iterations  = tree.int_input(     "Iterations", 20,    min_value=1, description="Number of iterations per line")
        delta       = tree.float_input(   "Delta",      .1,    min_value=.001, description="Distance to move at each iteration")
        direction   = tree.float_input(   "Direction",  1., description="Move forwards (+1) or backwards (-1)")

        # ----------------------------------------------------------------------------------------------------
        # Main

        with tree.layout("Starting points"):
            comps_node = tree.geometry.separate_components()
            points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
            points = points.points_to_vertices()

            points.store_named_float("DELTA", delta*direction)

        with tree.repeat(points=points, top=True, iterations=iterations) as rep:

            with tree.layout("Vector computation"):

                with tree.layout("Displacement from current points"):
                    v0 = field
                    l0 = v0.length()

                    rep.points.POINT[rep.top].store_named_float("Intensity", l0)

                    #rep.top &= l0 < 10
                    rep.top &= l0 > 0.001

                    v0 = v0.normalize().scale(rep.points.named_float("DELTA"))

                with tree.layout("Extrude from this first displacement"):

                    mesh = rep.points.POINT[rep.top].extrude_mesh(offset=v0)
                    top  = mesh.node.top

                with tree.layout("Displacement from extruded point"):

                    v1 = field
                    v1 = v1.normalize().scale(rep.points.named_float("DELTA"))
                    #v1 = tree.vector((0, 0, 0)).switch(average, (v1 - v0).scale(.5))
                    v1 = (v1 - v0).scale(.5)

                    rep.points.POINT[top].offset = v1

            rep.top    = top
            rep.points = mesh

        mesh = rep.points
        mesh.remove_named_attribute("DELTA")

        tree.geometry = mesh.mesh_to_curve()

    # =============================================================================================================================
    # Visualize a field computed by a group
    #
    # The group must take the following input nodes
    #
    # - Position     : locations where to compute the field
    # - kwargs       : kwargs passed in the function

    def gen_field_visualization(tree, field_node):

        # ----- Visualisation parameters

        elec_field  = tree.bool_input(  "Electric field",       True, description="Show electric field rather than magnetic field")
        color       = tree.color_input( "Color",                (0., 0., 1., 1.), description="'Color' named attribute to pass to the shader")
        transp      = tree.factor_input("Transparency",         0., min_value=0., max_value=1, description="'Transparency' named attribute to pass to the shader")

        # ----- Arrows

        scale       = tree.float_input( "Scale",                1., min_value=0., description="Vectors multiplicator")
        curl_vect   = tree.bool_input(  "Curl Vectors",         False, description="Use curl shape for arrows")

        # ----- Lines of field

        field_lines = tree.bool_input(  "Lines of field",       False, description="Lines of field (True) or field of vectors (False)")
        iterations  = tree.int_input(   "Iterations",           20, min_value=1, description="Number of iterations to compute the lines of field")
        delta       = tree.float_input( "Delta",                .1, min_value=.001, description="Distance to move at each iteration")
        int_fac     = tree.factor_input("Intensity",            1., min_value=0., max_value=1., description="Use intensity named attribute for radius")
        rand_dir    = tree.bool_input(  "Random Direction",     False, description="Build lines in random directions rather than in both directions")

        # ----- Geometry parameters

        resol       = tree.int_input(     "Resolution",         12, min_value=3, max_value=64, description="Lines / arrows section resolution")
        section     = tree.float_input(   "Section",            .02, min_value=0., max_value=1., description="Lines / arrows section")
        material    = tree.material_input("Material",           "Arrow", description="Arrows / lines material")

        # ----- Show / Hide

        show        = tree.bool_input(    "Show",               True, description="Show / hide flag")

        # ====================================================================================================
        # Utilities

        def get_field():
            return field_node.b.switch(elec_field, field_node.e)

        def build_lines(points, direction):
            return tree.group("Compute Lines of Field",
                geometry    = points,
                field       = get_field(),
                iterations  = iterations,
                delta       = delta,
                direction   = direction,
                ).geometry

        # ====================================================================================================
        # Main

        with tree.layout("Starting points"):
            comps_node = tree.geometry.separate_components()
            points = comps_node.point_cloud + comps_node.mesh.mesh_to_points()
            points = points.points_to_vertices()

        # ----------------------------------------------------------------------------------------------------
        # Arrows

        with tree.layout("Arrows"):

            points.store_named_vector("Vectors", get_field())

            arrows = tree.group("Arrows", points,
                scale         = scale,
                resolution    = resol,
                section       = section,
                sphere        = curl_vect,
                color         = color,
                transparency  = transp,
                shaft         = material,
                head          = material,
                ).geometry

        # ----------------------------------------------------------------------------------------------------
        # Lines of field

        with tree.layout("Lines of field"):
            curves  = build_lines(points, 1)
            curves += build_lines(points, -1)

            curves = curves.switch(rand_dir, build_lines(points, tree.integer(1).switch(tree.random_boolean(.5), -1)))

            lines = tree.group("To Lines of Field",
                    geometry         = curves,
                    resolution       = resol,
                    radius           = section,
                    intensity_factor = int_fac,
                    transparency     = transp,
                    color            = color,
                    material         = material,
                    ).geometry

        mesh = arrows.switch(field_lines, lines)

        # ----- Done

        return mesh.switch(-show)

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("Electric Field") as tree:

        # ----- Field parameters

        charges_obj = tree.object_input("Charges location", 1., description="Geometry proving the locations of the charges")
        charge_min  = tree.float_input( "Min Charge", -1., description="Minimum value for electric charge")
        charge_max  = tree.float_input( "Max Charge",  1., description="Maximum value for electric charge")
        seed = tree.int_input(          "Seed",        0,  description="Random seed")

        # ----- Main

        charges = charges_obj.object_info().geometry
        charges.POINT.store_named_float("Charge", tree.random_float(min=charge_min, max=charge_max, seed=seed))

        field_node = tree.group("G Electric Field",
            position = tree.position,
            charges  = charges,
            )

        tree.geometry = gen_field_visualization(tree, field_node)

    # ----------------------------------------------------------------------------------------------------
    # A charge moving along the X axis

    with gn.GeoNodes("X Moving Charge Field") as tree:

        # ----- Field parameters

        charge      = tree.float_input(  "Charge", 1., description="Value of the charge")
        beta        = tree.float_input(  "Beta",   0, min_value=-.999, max_value=.999, description="Beta relativist speed")
        t           = tree.float_input(  "t", description="Time")

        # ----- Main

        field_node = tree.group("G X Moving Charge Field",
            position = tree.position,
            charge   = charge,
            beta     = beta,
            t        = t)

        tree.geometry = gen_field_visualization(tree, field_node)

    # ----------------------------------------------------------------------------------------------------
    # A charge moving in an arbitrary direction

    with gn.GeoNodes("Moving Charge Field") as tree:

        # ----- Field parameters

        charge_loc  = tree.vector_input( "Charge location", description="Charge location")
        charge      = tree.float_input(  "Charge",  1., description="Value of the charge")
        speed       = tree.vector_input( "Speed", (.8, 0, 0), description="Charge speed (length must be less than 1)")

        # ----- Main

        field_node = tree.group("G Moving Charge Field",
            position        = tree.position,
            charge_location = charge_loc,
            speed           = speed,
            )

        tree.geometry = gen_field_visualization(tree, field_node)

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by several charges

    with gn.GeoNodes("Charges on Curve Field") as tree:

        # ----- Field parameters

        source_curve = tree.object_input(  "Source Curve", description="Curve on which charges are moving")
        count        = tree.int_input(     "Charges count",    10, min_value=1, max_value=1000, description="Number of charges")
        t            = tree.float_input(   "t",                0., description="Time for charges animation")
        charge       = tree.float_input(   "Charge",           1., description="Total charge")
        beta         = tree.float_input(   "Beta",             .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        sph_radius   = tree.float_input(   "Spheres Radius",   .1, min_value=0., description="Charges sphere radius (0 if charges must not be visualized)")
        sph_mat      = tree.material_input("Spheres Material", description="Charges material")

        # ----- Main

        curve = source_curve.object_info().geometry

        field_node = tree.group("G Charges on Curve Field",
            position        = tree.position,
            source_curve    = curve,
            count           = count,
            t               = t,
            charge          = charge,
            beta            = beta,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with tree.layout("Spheres"):

            sph_locs = field_node.charge_locations
            spheres = sph_locs.instance_on_points(instance=tree.UVSphere(radius=sph_radius).mesh)
            spheres.FACE.shade_smooth = True
            spheres.FACE.material = sph_mat

        tree.geometry = field_visu + spheres.switch(sph_radius.equal(0))

    # -----------------------------------------------------------------------------------------------------------------------------
    # Electromagnetic field generated by a solenoide

    with gn.GeoNodes("Solenoid Field") as tree:

        charge      = tree.float_input(  "Charge",      1., description="Total charge")
        beta        = tree.float_input(  "Beta",        .8, min_value=-.999, max_value=.999, description="Relativist speed beta")
        radius      = tree.float_input(  "Radius",      1., min_value=.1, max_value=10, description="Solenoid radius")
        length      = tree.float_input(  "Length",      5., min_value=.1, max_value=10, description="Solenoid length")

        # ---- Solenoid

        wire_radius  = tree.float_input(   "Wire radius", .1, min_value=.001, description="Radius of the wire (0 for no visualization)")
        wire_mat     = tree.material_input("Wire Material", description="Wire material")

        # ----- Main

        field_node = tree.group("G Solenoid Field",
            position        = tree.position,
            charge          = charge,
            beta            = beta,
            length          = length,
            )

        field_visu = gen_field_visualization(tree, field_node)

        with tree.layout("Solenoid"):

            loops = tree.min(30, tree.max(1, length/2/wire_radius))

            wire_curve = tree.Spiral(
                #resolution      = 32,
                rotations       = loops,
                start_radius    = radius,
                end_radius      = radius,
                height          = length,
                ).curve

            wire_curve.transform_geometry(translation=(-length/2, 0, 0), rotation=(0, np.pi/2, 0))

            wire = wire_curve.curve_to_mesh(profile_curve=tree.CurveCircle(radius=wire_radius, resolution=12).curve)

            wire.FACE.shade_smooth = True
            wire.FACE.material     = wire_mat

        tree.geometry = field_visu + wire.switch(wire_radius.equal(0))
